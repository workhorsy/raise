#!/usr/bin/env python
# -*- coding: UTF-8 -*-

'''
This file is part of Raise a small Python based build automation tool.
This project is hosted at http://launchpad.net/raise .

Copyright (c) 2012, Matthew Brennan Jones<mattjones@workhorsy.org>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met: 

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer. 
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies, 
either expressed or implied, of the FreeBSD Project.
'''

import os, sys, stat
import platform, re, glob
import shutil
import atexit
from subprocess import *
if sys.version_info < (3, 0):
	import urllib2
	globals()['urlopen'] = urllib2.urlopen
else:
	import urllib.request
	globals()['urlopen'] = urllib.request.urlopen

class bcolors:
	MESSAGE = '\033[44m'
	OK = '\033[42m'
	FAIL = '\033[41m'
	ENDC = '\033[0m'

def terminal_pad(command):
	width = int(os.popen('stty size', 'r').read().split()[1])
	if len(command) > (width-2):
		i = int(width * (int(len(command) / width) + 1)) - 2
	else:
		i = width - 2

	return command.ljust(i)

def print_info(message):
	sys.stdout.write(bcolors.MESSAGE + message + bcolors.ENDC + "\n")

def print_status(message):
	sys.stdout.write(terminal_pad('{0} ...'.format(message)))
	sys.stdout.flush()

def print_ok():
	print(bcolors.OK + ":)" + bcolors.ENDC)

def print_fail():
	print(bcolors.FAIL + ":(" + bcolors.ENDC)

def print_exit(message):
	print(bcolors.FAIL + message + ' Exiting ...' + bcolors.ENDC)
	exit()

# Move the path to the location of the current file
os.chdir(os.sys.path[0])
pwd = os.sys.path[0]

# Make sure we are in at least python 2.6
if sys.version_info < (2, 6):
	print_exit("Python 2.6 or greater is required.")
# Figure out if the CPU is 32bit or 64bit
bits = None
if platform.architecture()[0] == '64bit':
	bits = '64'
else:
	bits = '32'

# Figure out the CPU architecture
arch = None
if re.match('^i\d86', platform.machine()):
	arch = 'i386'
elif platform.machine() == 'x86_64':
	arch = 'x86_64'
else:
	print_exit("Unknown architecture: " + platform.machine() + " .")

user_name = os.environ["LOGNAME"]
if os.getenv("SUDO_USER"):
	user_name = os.getenv("SUDO_USER")

def require_root():
	# Make sure we are root
	if run('whoami') != 'root':
		print_exit("Must be run as root.")

def call_on_exit(cb):
	# Set a cleanup function to run on exit
	if cb:
		atexit.register(cb)

def require_not_root():
	# Make sure we are NOT root
	if run('whoami') == 'root':
		print_exit("Must not be run as root.")

def run(command):
	p = Popen(command, stderr=PIPE, stdout=PIPE, shell=True)
	p.wait()
	e = p.stderr.read().rstrip()
	o = p.stdout.read().rstrip()
	try:
		e = str(e, 'UTF-8')
	except:
		pass
	try:
		o = str(o, 'UTF-8')
	except:
		pass

	if p.returncode:
		if len(e) != 0:
			raise Exception(e)
		else:
			raise Exception(o)

	return o

def run_say(command):
	sys.stdout.write("Running command ...\n")
	p = Popen(command, stderr=PIPE, stdout=PIPE, shell=True)
	p.wait()
	o = p.stdout.read().rstrip()
	e = p.stderr.read().rstrip()
	try:
		e = str(e, 'UTF-8')
	except:
		pass
	try:
		o = str(o, 'UTF-8')
	except:
		pass

	if p.returncode:
		sys.stdout.write(terminal_pad(command))
		print_fail()
		if len(o):
			print(o)
		if len(e):
			print(e)
		print_exit('Failed to run command.')
	else:
		sys.stdout.write(terminal_pad(command))
		print_ok()
		if len(o):
			print(o)
		if len(e):
			print(e)

def cd(name):
	print_status("Changing to dir '{0}'".format(name))
	try:
		os.chdir(name)
		print_ok()
	except:
		print_fail()
		print_exit("Failed to change to another directory.".format(name))

def mvfile(source, dest):
	print_status("Moving the file '{0}' to '{1}'".format(source, dest))
	os.rename(source, dest)
	try:
		
		print_ok()
	except:
		print_fail()
		print_exit("Failed to move the file' {0}'.".format(source))

def cpfile(source, dest):
	print_status("Copying the file '{0}' to '{1}'".format(source, dest))
	try:
		shutil.copy2(source, dest)
		print_ok()
	except:
		print_fail()
		print_exit("Failed to copy the file '{0}' to '{1}'.".format(source, dest))

def cpdir(source, dest, symlinks = False):
	print_status("Copying the dir '{0}' to '{1}'".format(source, dest))
	try:
		shutil.copytree(source, dest, symlinks = symlinks)
		print_ok()
	except:
		print_fail()
		print_exit("Failed to copy the dir '{0}' to '{1}'.".format(source, dest))

def mkdir_f(source):
	print_status("Making the dir '{0}'".format(source))
	try:
		os.mkdir(source)
	except:
		pass

	print_ok()

def mkdir(source):
	print_status("Making the dir '{0}'".format(source))
	try:
		os.mkdir(source)
		print_ok()
	except:
		print_fail()
		print_exit("Failed to make the dir '{0}'.".format(source))

def rmdir_and_children(name):
	print_status("Removing the dir '{0}'".format(name))
	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isdir(name):
			shutil.rmtree(name)
		print_ok()
	except OSError as e:
		if 'No such file or directory' in e:
			print_ok()
			return
		print_fail()
		print_exit("Failed to remove the dir '{0}'.".format(name))

def rmdir(name):
	print_status("Removing the dir '{0}'".format(name))
	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isdir(name):
			os.rmdir(name)
	except OSError as e:
		if 'Directory not empty' in e:
			pass
		elif 'No such file or directory' in e:
			pass
		else:
			print_fail()
			print_exit("Failed to remove the dir '{0}'.".format(name))

	print_ok()

def rmfile(name):
	print_status("Removing the file '{0}'".format(name))
	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isfile(name):
			os.rmdir(name)
		print_ok()
	except:
		print_fail()
		print_exit("Failed to remove the file '{0}'.".format(name))

def rmfile_f(name):
	print_status("Removing the file '{0}'".format(name))
	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isfile(name):
			os.remove(name)
	except:
		pass

	print_ok()

def symlink(source, link_name):
	print_status("Symlinking '{0}' to '{1}'".format(source, link_name))
	try:
		os.symlink(source, link_name)
		print_ok()
	except:
		print_fail()
		print_exit("Failed linking '{0}' to '{1}'.".format(source, link_name))

def _get_library_paths():
	paths = ['/usr/lib']
	for file_name in os.listdir('/etc/ld.so.conf.d/'):
		f = open('/etc/ld.so.conf.d/' + file_name, 'r')
		for path in f.readlines():
			path = path.strip()
			if os.path.exists(path) and not path in paths:
				paths.append(path)

	return paths

def _is_installed_library(lib_name, extension):
	for path in _get_library_paths():
		for dirs, subdirs, files in os.walk(path):
			for f in files:
				if f.endswith(extension):
					if os.path.join(dirs, f).endswith(lib_name + extension):
						return True

	return False

def _library_path(lib_name, extension):
	lib_name += extension
	for path in _get_library_paths():
		for dirs, subdirs, files in os.walk(path):
			for f in files:
				file_name = lib_name.split('/')[-1]
				path_end = lib_name[0:-(len(file_name)+1)]
				if dirs.endswith(path_end) and f == file_name:
					return os.path.join(dirs, file_name)

	raise Exception("Library '{0}' not found.".format(lib_name))

def require_static_library(lib_name):
	print_status("Checking for static library '{0}'".format(lib_name))
	is_installed = _is_installed_library(lib_name, '.a')

	# Make them install the lib to continue
	if not is_installed:
		print_fail()
		print_exit("Static library '{0}.a' not installed. Install and try again.".format(lib_name))

	# Make them run updatedb if the library is not found by locate
	try:
		run("locate /" + lib_name + ".a")
		print_ok()
	except:
		print_fail()
		print_exit("Static library '{0}' not found with 'locate'. Run 'sudo updatedb' and try again.".format(lib_name))

def require_shared_library(lib_name):
	print_status("Checking for shared library '{0}'".format(lib_name))
	is_installed = _is_installed_library(lib_name, '.so')

	# Make them install the lib to continue
	if not is_installed:
		print_fail()
		print_exit("Shared library '{0}.so' not installed. Install and try again.".format(lib_name))

	# Make them run ldconfig if the library is not found by ldconfig
	try:
		run("ldconfig -p | grep \"" + lib_name + "\.so (\"")
		print_ok()
	except:
		print_fail()
		print_exit("Shared library '{0}' not found with 'ldconfig'. Run 'sudo ldconfig' and try again.".format(lib_name))

def require_static_or_shared_library(lib_name):
	print_status("Checking for static/shared library '{0}'".format(lib_name))
	is_static_installed = _is_installed_library(lib_name, '.a')
	is_shared_installed = _is_installed_library(lib_name, '.so')

	# Make them install the lib to continue
	if not is_static_installed and not is_shared_installed:
		print_fail()
		print_exit("Static/Shared library '{0}' not installed. Install and try again.".format(lib_name))

	# Make them run updatedb if the library is not found by locate
	if is_static_installed:
		try:
			run("locate /" + lib_name + ".a")
			print_ok()
			return
		except:
			print_fail()
			print_exit("Static library '{0}' not found with 'locate'. Run 'sudo updatedb' and try again.".format(lib_name))

	# Make them run ldconfig if the library is not found by ldconfig
	if is_shared_installed:
		try:
			run("ldconfig -p | grep \"" + lib_name + "\.so (\"")
			print_ok()
		except:
			print_fail()
			print_exit("Shared library '{0}' not found with 'ldconfig'. Run 'sudo ldconfig' and try again.".format(lib_name))


def require_static_libraries(lib_names):
	for lib_name in lib_names:
		require_static_library(lib_name)

def require_shared_libraries(lib_names):
	for lib_name in lib_names:
		require_shared_library(lib_name)

def require_static_or_shared_libraries(lib_names):
	for lib_name in lib_names:
		require_static_or_shared_library(lib_name)

def require_programs(prog_names):
	for prog_name in prog_names:
		print_status("Checking for program '{0}'".format(prog_name))

		try:
			output = run('which {0}'.format(prog_name))
			print_ok()
		except:
			print_fail()
			print_exit("Install the program '{0}' and try again.".format(prog_name))

def require_python_modules(mod_names):
	for mod_name in mod_names:
		print_status("Checking for python module '{0}'".format(mod_name))
		try:
			exec("import {0}".format(mod_name))
			print_ok()
		except ImportError as e:
			print_fail()
			print_exit("Install the python module '{0}' and try again.".format(mod_name))

def header_path(header_name):
	retval = None
	try:
		# Get any paths that contain the library name
		paths = run('locate /' + header_name).split('\\n')

		# First match paths that contain the architecture
		for path in paths:
			if 'lib' + bits in path or arch in path:
				retval = path

		# If none were matched specifically from the architecture
		# Use the first
		if retval == None:
			retval = paths[0]
	except:
		pass

	if not retval or not os.path.exists(retval):
		raise Exception("Header file not found: '" + header_name + "'")

	i = retval.rfind('/') + 1
	return retval[:i]

def header_paths(header_names):
	paths = []
	for header_name in header_names:
		paths.append(header_path(header_name))

	return paths

def include_path(header_name):
	return '-I' + header_path(header_name)

def include_paths(header_names):
	paths = []
	for header_name in header_names:
		paths.append(include_path(header_name))
	return str.join(' ', paths)

def shared_library_path(lib_name):
	return _library_path(lib_name, '.so')

def static_library_path(lib_name):
	return _library_path(lib_name, '.a')

def static_or_shared_library_path(lib_name):
	try:
		return static_library_path(lib_name)
	except:
		pass

	try:
		return shared_library_path(lib_name)
	except:
		pass

	raise Exception("Static/Shared library not found: '" + lib_name + "'")

def link_shared_path(lib_name):
	return '-L' + shared_library_path(lib_name)

def link_static_path(lib_name):
	return '-L' + static_library_path(lib_name)

def link_static_or_shared_path(lib_name):
	return '-L' + static_or_shared_library_path(lib_name)

def link_shared_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_shared_path(lib_name))
	return str.join(' ', paths)

def link_static_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_static_path(lib_name))
	return str.join(' ', paths)

def link_static_or_shared_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_static_or_shared_path(lib_name))
	return str.join(' ', paths)

def cc_build_object(o_file, c_files):
	print_status("Building object file '{0}'".format(o_file))
	try:
		run("gcc ${CFLAGS} -c -o " + o_file + " " + str.join(' ', c_files) + " ${GLIB_INC}")
		print_ok()
	except Exception as e:
		print_fail()
		print(e.message)
		print_exit("Build failed. Try again.")

def ar_build_static_library(ar_file, o_files):
	print_status("Building static library '{0}'".format(ar_file))
	try:
		run("ar rcs " + ar_file + " " + str.join(' ', o_files))
		print_ok()
	except Exception as e:
		print_fail()
		print(e.message)
		print_exit("Archive failed. Try again.")

def dmd_build_object(o_file, d_files, i_files, l_files, h_files):
	print_status("Building object file '{0}'".format(o_file))
	try:
		command = "dmd ${DFLAGS} -c -of" + o_file + " " + str.join(' ', d_files) + " " + str.join(' ', i_files) + " " + str.join(' ', l_files) + "  -Hdimport -Hf" + str.join(' ', h_files) + " ${GLIB_INC}"
		run(command)
		print_ok()
	except Exception as e:
		print_fail()
		print(e.message)
		print_exit("Build failed. Try again.")

def dmd_build_program(out_file, inc_files, link_files=[]):
	print_status("Building program '{0}'".format(out_file))
	try:
		command = "dmd ${DFLAGS} -of" + out_file + ' ' + str.join(' ', inc_files) + " " + str.join(' ', link_files)
		run(command)
		print_ok()
	except Exception as e:
		print_fail()
		print(e.message)
		print_exit("Build failed. Try again.")

def load_rscript(g=globals(), l=locals()):
	if not os.path.isfile('rscript'):
		print_exit("No 'rscript' file found.")

	with open('rscript', 'rb') as f:
		code = None
		try:
			code = compile(f.read(), 'rscript', 'exec')
		except Exception as e:
			print_exit(e)

		exec(code, g, l)

def friendly_size(data_length):
	retval = ''
	size_map = [
		{'B'  : 1},
		{'KB' : 1024.0},
		{'MB' : 1024000.0}
	]
	for i in size_map:
		for name, size in i.items():
			if data_length >= size:
				retval = '{0} {1}'.format(round(data_length / size, 2), name)
				break

	return retval

def download_file(url, cb):
	chunk_size = 1024
	response = urlopen(url)
	content_length = int(response.headers['Content-Length'])
	data = b''
	data_length = 0

	while True:
		chunk = response.read(chunk_size)
		if not chunk:
			break

		data += chunk
		data_length += len(chunk)
		percent = round((float(data_length) / content_length)*100, 2)

		cb(chunk, data_length, chunk_size, content_length, percent)

def update():
	print("Downloading newest Raise version ...".format(target_name))
	try:
		url = 'http://bazaar.launchpad.net/~workhorsy/raise/main/download/head:/raise-20120417054845-dmqxla979coc2eqq-1/raise'
		f = open('raise.new', 'wb')

		def cb(chunk, data_length, chunk_size, content_length, percent):
			f.write(chunk)

			sys.stdout.write("Downloaded {0} of {1} ({2}%)\r".format(friendly_size(data_length), friendly_size(content_length), percent))

			if data_length >= content_length:
				sys.stdout.write('\n')

			sys.stdout.flush()

		download_file(url, cb)
		print_ok()
	except Exception as e:
		print_fail()
		print_exit(str(e))
		exit()

	mvfile('raise', 'raise.old')
	mvfile('raise.new', 'raise')
	os.chmod('raise', stat.S_IRWXU| stat.S_IRWXG| stat.S_IROTH | stat.S_IXOTH)
	rmfile('raise.old')
	exit()

if __name__ == '__main__':
	load_rscript()
	target_name = str(str.join(' ', sys.argv[1:]))

	# Try running a function with the same name as the target
	if target_name == '':
		print_exit("No target specified.")
	elif target_name == 'update':
		update()

	try:
		target = eval(target_name)
		print_info("Running target '{0}'".format(target_name))
		target()
	except NameError as e:
		if str(e) == "name '{0}' is not defined".format(target_name):
			print_exit("No target named '{0}'.".format(target_name))
		else:
			raise
	except Exception as e:
		raise





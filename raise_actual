#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# This file is part of Raise a small build automation tool.
# This project is hosted at http://launchpad.net/raise .
# Copyright (c) 2012, Matthew Brennan Jones <mattjones@workhorsy.org>
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
# 
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import os, sys, stat
import signal
import platform, re, glob
import shutil
import atexit
from subprocess import *
if sys.version_info < (3, 0):
	import urllib2
	globals()['urlopen'] = urllib2.urlopen
else:
	import urllib.request
	globals()['urlopen'] = urllib.request.urlopen

class bcolors:
	MESSAGE = '\033[44m'
	OK = '\033[42m'
	FAIL = '\033[41m'
	ENDC = '\033[0m'

def terminal_pad(length, pad_char=' '):
	width = int(os.popen('stty size', 'r').read().split()[1])
	if length > (width-2):
		i = int(width * (int(length / width) + 1)) - 2
	else:
		i = width - 2
	return ''.ljust(i-length, pad_char)

def print_info(message):
	sys.stdout.write(bcolors.MESSAGE + message + bcolors.ENDC + "\n")
	sys.stdout.flush()

def print_status(message):
	message = '{0} ...'.format(message)
	sys.stdout.write(message)
	sys.stdout.flush()
	return len(message)

def print_ok(length):
	sys.stdout.write(terminal_pad(length) + bcolors.OK + ":)" + bcolors.ENDC)
	sys.stdout.flush()

def print_fail(length):
	sys.stdout.write(terminal_pad(length, '.') + bcolors.FAIL + ":(" + bcolors.ENDC)
	sys.stdout.flush()

def print_exit(message):
	sys.stdout.write(bcolors.FAIL + message + ' Exiting ...' + bcolors.ENDC + '\n')
	sys.stdout.flush()
	exit()

def require_root():
	# Make sure we are root
	if run('whoami') != 'root':
		print_exit("Must be run as root.")

def require_not_root():
	# Make sure we are NOT root
	if run('whoami') == 'root':
		print_exit("Must not be run as root.")

def call_on_exit(cb):
	# Set a cleanup function to run on exit
	if cb:
		atexit.register(cb)

def run(command):
	p = Popen(command, stderr=PIPE, stdout=PIPE, shell=True)
	p.wait()
	e = p.stderr.read().rstrip()
	o = p.stdout.read().rstrip()
	try:
		e = str(e, 'UTF-8')
	except Exception as err:
		pass
	try:
		o = str(o, 'UTF-8')
	except Exception as err:
		pass

	if p.returncode:
		if len(e) != 0:
			raise Exception(e)
		else:
			raise Exception(o)

	return o

# FIXME: Rename to run_print
def run_say(command):
	message = "Running command ..."
	length = len(message)
	sys.stdout.write(message)
	sys.stdout.flush()
	p = Popen(command, stderr=PIPE, stdout=PIPE, shell=True)
	p.wait()
	o = p.stdout.read().rstrip()
	e = p.stderr.read().rstrip()
	try:
		e = str(e, 'UTF-8')
	except Exception as err:
		pass
	try:
		o = str(o, 'UTF-8')
	except Exception as err:
		pass

	if p.returncode:
		print_fail(length)
		if len(o):
			print(o)
		if len(e):
			print(e)
		print_exit('Failed to run command.')
	else:
		print_ok(length)
		if len(o):
			print(o)
		if len(e):
			print(e)

def _do_on_fail_exit(start_message, fail_message, cb):
	length = print_status(start_message)
	try:
		cb()
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print_exit(fail_message)

def _do_on_fail_pass(start_message, bc):
	length = print_status(start_message)
	try:
		cb()
	except Exception as e:
		pass
	print_ok(length)

def cd(name):
	_do_on_fail_exit("Changing to dir '{0}'".format(name),
					"Failed to change to the dir '{0}'.".format(name),
				lambda: os.chdir(name))

def mvfile(source, dest):
	_do_on_fail_exit("Moving the file '{0}' to '{1}'".format(source, dest),
					"Failed to move the file' {0}'.".format(source),
				lambda: os.rename(source, dest))

def cpfile(source, dest):
	_do_on_fail_exit("Copying the file '{0}' to '{1}'".format(source, dest),
					"Failed to copy the file '{0}' to '{1}'.".format(source, dest),
				lambda: shutil.copy2(source, dest))

def cpdir(source, dest, symlinks = False):
	_do_on_fail_exit("Copying the dir '{0}' to '{1}'".format(source, dest),
					"Failed to copy the dir '{0}' to '{1}'.".format(source, dest),
				lambda: shutil.copytree(source, dest, symlinks = symlinks))

def mkdir_f(source):
	_do_on_fail_pass("Making the dir '{0}'".format(source),
				lambda: os.mkdir(source))

def mkdir(source):
	_do_on_fail_exit("Making the dir '{0}'".format(source),
					"Failed to make the dir '{0}'.".format(source),
				lambda: os.mkdir(source))

def rmdir_and_children(name):
	length = print_status("Removing the dir '{0}'".format(name))
	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isdir(name):
			shutil.rmtree(name)
		print_ok(length)
	except OSError as e:
		if 'No such file or directory' in e:
			print_ok(length)
			return
		print_fail(length)
		print_exit("Failed to remove the dir '{0}'.".format(name))

def rmdir(name):
	length = print_status("Removing the dir '{0}'".format(name))
	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isdir(name):
			os.rmdir(name)
	except OSError as e:
		if 'Directory not empty' in e:
			pass
		elif 'No such file or directory' in e:
			pass
		else:
			print_fail(length)
			print_exit("Failed to remove the dir '{0}'.".format(name))

	print_ok(length)

def rmfile(name):
	length = print_status("Removing the file '{0}'".format(name))
	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isfile(name):
			os.remove(name)
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print_exit("Failed to remove the file '{0}'.".format(name))

def rmfile_f(name):
	length = print_status("Removing the file '{0}'".format(name))
	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isfile(name):
			os.remove(name)
	except Exception as e:
		pass

	print_ok(length)

def symlink(source, link_name):
	_do_on_fail_exit("Symlinking '{0}' to '{1}'".format(source, link_name),
					"Failed linking '{0}' to '{1}'.".format(source, link_name),
				lambda: os.symlink(source, link_name))

def ldconfig():
	_do_on_fail_exit("Running 'ldconfig'",
					"Failed run 'ldconfig'.",
				lambda: run('ldconfig'))

def updatedb():
	_do_on_fail_exit("Running 'updatedb'",
					"Failed run 'updatedb'.",
				lambda: run('updatedb'))

# Returns all the paths that libraries are installed in
def _get_library_paths():
	paths = ['/usr/lib']
	for file_name in os.listdir('/etc/ld.so.conf.d/'):
		f = open('/etc/ld.so.conf.d/' + file_name, 'r')
		for path in f.readlines():
			path = path.strip()
			if os.path.exists(path) and not path in paths:
				paths.append(path)

	return paths

# Returns the full path of a library file or None
def _get_library_path(lib_name, extension):
	lib_name += extension
	for path in _get_library_paths():
		for dirs, subdirs, files in os.walk(path):
			for f in files:
				file_name = lib_name.split('/')[-1]
				path_end = lib_name[0:-(len(file_name)+1)]
				if dirs.endswith(path_end) and f == file_name:
					return os.path.join(dirs, file_name)

	return None

# Returns true if a library is installed
def _is_library_installed(lib_name, extension):
	if _get_library_path(lib_name, extension):
		return True
	else:
		return False

# Returns the full path of a library file or throws and exception
def _library_path(lib_name, extension):
	path = _get_library_path(lib_name, extension)
	if path:
		return path
	else:
		raise Exception("Library '{0}' not found.".format(lib_name))

def require_static_library(lib_name):
	length = print_status("Checking for static library '{0}'".format(lib_name))
	is_installed = _is_library_installed(lib_name, '.a')

	# Make them install the lib to continue
	if not is_installed:
		print_fail(length)
		print_exit("Static library '{0}' not installed. Install and try again.".format(lib_name))

	# Make them run updatedb if the library is not found by locate
	try:
		run("locate /" + lib_name + ".a")
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print_exit("Static library '{0}' not found with 'locate'. Run 'sudo updatedb' and try again.".format(lib_name))

def require_shared_library(lib_name):
	length = print_status("Checking for shared library '{0}'".format(lib_name))
	is_installed = _is_library_installed(lib_name, '.so')

	# Make them install the lib to continue
	if not is_installed:
		print_fail(length)
		print_exit("Shared library '{0}' not installed. Install and try again.".format(lib_name))

	# Make them run ldconfig if the library is not found by ld
	try:
		run("ld -l " + lib_name.lstrip('lib') + ' -o /dev/null')
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print_exit("Shared library '{0}' not found with 'ld'. Run 'sudo ldconfig' and try again.".format(lib_name))

def require_static_or_shared_library(lib_name):
	length = print_status("Checking for static/shared library '{0}'".format(lib_name))
	is_static_installed = _is_library_installed(lib_name, '.a')
	is_shared_installed = _is_library_installed(lib_name, '.so')

	# Make them install the lib to continue
	if not is_static_installed and not is_shared_installed:
		print_fail(length)
		print_exit("Static/Shared library '{0}' not installed. Install and try again.".format(lib_name))

	# Make them run updatedb if the library is not found by locate
	if is_static_installed:
		try:
			run("locate /" + lib_name + ".a")
			print_ok(length)
			return
		except Exception as e:
			print_fail(length)
			print_exit("Static library '{0}' not found with 'locate'. Run 'sudo updatedb' and try again.".format(lib_name))

	# Make them run ldconfig if the library is not found by ld
	if is_shared_installed:
		try:
			run("ld -l " + lib_name.lstrip('lib') + ' -o /dev/null')
			print_ok(length)
		except Exception as e:
			print_fail(length)
			print_exit("Shared library '{0}' not found with 'ld'. Run 'sudo ldconfig' and try again.".format(lib_name))

def require_static_libraries(lib_names):
	for lib_name in lib_names:
		require_static_library(lib_name)

def require_shared_libraries(lib_names):
	for lib_name in lib_names:
		require_shared_library(lib_name)

def require_static_or_shared_libraries(lib_names):
	for lib_name in lib_names:
		require_static_or_shared_library(lib_name)

def require_raise_dependencies(prog_names):
	fails = []
	# See which programs are not installed
	for prog_name in prog_names:
		cb = lambda: run('which {0}'.format(prog_name))
		try:
			cb()
		except Exception as e:
			fails.append(prog_name)

	# Print them in a list then exit
	if fails:
		print_info("Raise is checking for its dependencies")
		for f in fails:
			length = print_status("Checking for program '{0}'".format(f))
			print_fail(length)
		print_exit("Install the dependencies '{0}' and try again.".format(str.join("', '", fails)))

def require_programs(prog_names):
	for prog_name in prog_names:
		_do_on_fail_exit("Checking for program '{0}'".format(prog_name),
				"Install the program '{0}' and try again.".format(prog_name),
				lambda: run('which {0}'.format(prog_name)))

def require_python_modules(mod_names):
	for mod_name in mod_names:
		_do_on_fail_exit("Checking for python module '{0}'".format(mod_name),
						"Install the python module '{0}' and try again.".format(mod_name),
					lambda: run('{0} -c "import {1}"'.format(python, mod_name)))

def header_path(header_name):
	retval = None
	try:
		# Get any paths that contain the library name
		paths = run('locate /' + header_name).split('\n')

		# First match paths that contain the architecture
		for path in paths:
			if 'lib' + bits in path or arch in path:
				retval = path

		# If none were matched specifically from the architecture
		# Use the first
		if retval == None:
			retval = paths[0]
	except Exception as e:
		pass

	if not retval or not os.path.exists(retval):
		raise Exception("Header file not found: '" + header_name + "'")

	i = retval.rfind('/') + 1
	return retval[:i]

def header_paths(header_names):
	paths = []
	for header_name in header_names:
		paths.append(header_path(header_name))

	return paths

def include_path(header_name):
	return '-I' + header_path(header_name)

def include_paths(header_names):
	paths = []
	for header_name in header_names:
		paths.append(include_path(header_name))
	return str.join(' ', paths)

def shared_library_path(lib_name):
	return _library_path(lib_name, '.so')

def static_library_path(lib_name):
	return _library_path(lib_name, '.a')

def static_or_shared_library_path(lib_name):
	try:
		return static_library_path(lib_name)
	except Exception as e:
		pass

	try:
		return shared_library_path(lib_name)
	except Exception as e:
		pass

	raise Exception("Static/Shared library not found: '" + lib_name + "'")

def link_shared_path(lib_name):
	return '-L' + shared_library_path(lib_name)

def link_static_path(lib_name):
	return '-L' + static_library_path(lib_name)

def link_static_or_shared_path(lib_name):
	return '-L' + static_or_shared_library_path(lib_name)

def link_shared_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_shared_path(lib_name))
	return str.join(' ', paths)

def link_static_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_static_path(lib_name))
	return str.join(' ', paths)

def link_static_or_shared_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_static_or_shared_path(lib_name))
	return str.join(' ', paths)

def c_build_object(o_file, c_files, i_files=[]):
	length = print_status("Building C object file '{0}'".format(o_file))
	try:
		if not 'CC' in os.environ:
			print_fail(length)
			print_exit("Set the env variable 'CC' to the C compiler, and try again.")

		run("${CC} ${CFLAGS} -c -o " + o_file + ' ' + str.join(' ', c_files) + ' ' + str.join(' ', i_files))
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print(e)
		print_exit("Build failed. Try again.")

def c_build_program(o_file, c_files, i_files=[]):
	length = print_status("Building C program '{0}'".format(o_file))
	try:
		if not 'CC' in os.environ:
			print_fail(length)
			print_exit("Set the env variable 'CC' to the C compiler, and try again.")

		run("${CC} ${CFLAGS} -o " + o_file + ' ' + str.join(' ', c_files) + ' ' + str.join(' ', i_files))
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print(e)
		print_exit("Build failed. Try again.")

# FIXME: Rename to c_build_static_library
def ar_build_static_library(ar_file, o_files):
	length = print_status("Building static library '{0}'".format(ar_file))
	try:
		run("ar rcs " + ar_file + " " + str.join(' ', o_files))
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print(e)
		print_exit("Archive failed. Try again.")

def c_build_shared_library(so_file, o_files):
	length = print_status("Building shared library '{0}'".format(so_file))
	try:
		command = "ld -G {0} -o {1}".format(str.join(' ', o_files), so_file)
		run(command)
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print(e)
		print_exit("Building shared library failed. Try again.")

def d_build_object(o_file, d_files, i_files, l_files=[], h_files=[]):
	length = print_status("Building D object file '{0}'".format(o_file))
	try:
		if not 'DC' in os.environ:
			print_fail(length)
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		command = "${DC} ${DFLAGS} -c -of" + o_file + " " + str.join(' ', d_files) + " " + str.join(' ', i_files) + " " + str.join(' ', l_files)
		if h_files:
			command + "  -Hdimport -Hf" + str.join(' ', h_files)
		run(command)
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print(e)
		print_exit("Build failed. Try again.")

def d_build_shared_library(o_file, d_files, i_files, l_files=[], h_files=[]):
	length = print_status("Building D shared library '{0}'".format(o_file))
	try:
		if not 'DC' in os.environ:
			print_fail(length)
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		command = "${DC} ${DFLAGS} -shared -of" + o_file + " " + str.join(' ', d_files) + " " + str.join(' ', i_files) + " " + str.join(' ', l_files)
		if h_files:
			command + "  -Hdimport -Hf" + str.join(' ', h_files)
		run(command)
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print(e)
		print_exit("Build failed. Try again.")

def d_build_static_library(o_file, d_files, i_files, l_files, h_files):
	length = print_status("Building D static library '{0}'".format(o_file))
	try:
		if not 'DC' in os.environ:
			print_fail(length)
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		command = "${DC} ${DFLAGS} -lib -of" + o_file + " " + str.join(' ', d_files) + " " + str.join(' ', i_files) + " " + str.join(' ', l_files) + "  -Hdimport -Hf" + str.join(' ', h_files)
		run(command)
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print(e)
		print_exit("Build failed. Try again.")

def d_build_program(out_file, inc_files, link_files=[]):
	length = print_status("Building D program '{0}'".format(out_file))
	try:
		if not 'DC' in os.environ:
			print_fail(length)
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		command = "${DC} ${DFLAGS} -of" + out_file + ' ' + str.join(' ', inc_files) + " " + str.join(' ', link_files)
		run(command)
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print(e)
		print_exit("Build failed. Try again.")

def load_rscript(g=globals(), l=locals()):
	# Make sure there is an rscript file
	if not os.path.isfile('rscript'):
		print_exit("No 'rscript' file found.")

	# Get a list of all the functions
	before = []
	for key in globals().keys():
		before.append(key)

	# Load the rscript file into this namespace
	with open('rscript', 'rb') as f:
		code = None
		try:
			code = compile(f.read(), 'rscript', 'exec')
		except Exception as e:
			print_exit(e)

		exec(code, g, l)

	# Get just the target functions
	targets = {}
	for key in globals().keys():
		if not key in before:
			if hasattr(globals()[key], '__call__'):
				targets[key] = globals()[key]

	return targets

if __name__ == '__main__':
	global pwd
	global python
	global bits
	global arch
	global user_name
	global target_name

	# Have all KeyboardInterrupt exceptions quit with a clean message
	def signal_handler(signal, frame):
		print_exit('Exit called by the keyboard.')
		exit()
	signal.signal(signal.SIGINT, signal_handler)

	# Get the path of the rscript file
	pwd = os.sys.path[0]

	# Make sure we are in at least python 2.6
	if sys.version_info < (2, 6):
		print_exit("Python 2.6 or greater is required.")

	# Get the name of the current running python program
	python = sys.executable
	if not python:
		print_exit('Could not find python to run child processes with.')

	# Figure out if the CPU is 32bit or 64bit
	bits = None
	if platform.architecture()[0] == '64bit':
		bits = '64'
	else:
		bits = '32'

	# Figure out the CPU architecture
	arch = None
	if re.match('^i\d86', platform.machine()):
		arch = 'i386'
	elif platform.machine() == 'x86_64':
		arch = 'x86_64'
	else:
		print_exit("Unknown architecture: " + platform.machine() + " .")

	# Get the user name
	user_name = os.environ["LOGNAME"]
	if os.getenv("SUDO_USER"):
		user_name = os.getenv("SUDO_USER")

	# Load the rscript
	targets = load_rscript()

	# Get the target function name
	target_name = str(str.join(' ', sys.argv[1:]))

	# Get a friendly list of all the targets
	target_list = []
	if targets:
		keys = targets.keys()
		keys.sort()
		target_list = "'" + str.join("', '", keys) + "'"

	# Exit if there is no target
	if not target_name:
		keys = targets.keys()
		keys.sort()
		print("Raise version 0.1 (July 27 2012)")
		print("A small build automation tool that ships with your code.")
		print("Copyright (c) 2012 Matthew Brennan Jones <mattjones@workhorsy.org>")
		print("")
		print("Raise is hosted at:")
		print("http://launchpad.net/raise")
		print("")
		print("Raise uses a MIT / X / Expat style license. Which can be found at:")
		print("http://bazaar.launchpad.net/~workhorsy/raise/main/view/head:/LICENSE")
		print("")
		print_exit("No target specified. Found targets are {0}.".format(target_list))
	
	# Exit if there is no target with that name
	if not target_name in targets:
		print_exit("No target named '{0}'. Found targets are {1}.".format(target_name, target_list))

	# Make sure all the programs we need are installed
	# FIXME: Requiring gcc, ar, ld, and ldconfig makes raise
	# gcc specific. What other linkers and archivers are used
	# with other C compilers? Clang, MS cl, et cetera
	require_raise_dependencies([
		'which', 'clear', 'locate', 'whoami', 'grep', 'stty', 'updatedb',
		'gcc', 'ar', 'ld'])

	# Try running the target
	target = targets[target_name]
	print_info("Running target '{0}'".format(target_name))
	target()





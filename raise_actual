#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# This file is part of Raise.
# Raise is a small software build tool that ships with your code.
# Raise uses a MIT style license, and is hosted at http://launchpad.net/raise .
# Copyright (c) 2013, Matthew Brennan Jones <mattjones@workhorsy.org>
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
# 
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


import os, sys, stat
import tempfile
import time
import filecmp
import signal
import platform, re, glob
import shutil
import atexit
import threading
import multiprocessing
import subprocess
import traceback
if sys.version_info < (3, 0):
	import urllib2
	globals()['urlopen'] = urllib2.urlopen
else:
	import urllib.request
	globals()['urlopen'] = urllib.request.urlopen


global pwd
global python
global bits
global arch
global target_name
global terminal_clear
global terminal_width
global message_length

def early_exit(message):
	sys.stdout.write(message + ' Exiting ...\n')
	sys.stdout.flush()
	exit()

target_name = None
cpus_total = multiprocessing.cpu_count()
cpus_free = cpus_total

# Get the path of the rscript file
pwd = os.sys.path[0]


# Make sure we are in at least python 2.6
if sys.version_info < (2, 6):
	early_exit("Python 2.6 or greater is required.")

# Get the name of the current running python program
python = sys.executable
if not python:
	early_exit('Could not find python to run child processes with.')

# Figure out if the CPU is 32bit or 64bit
bits = None
if platform.architecture()[0] == '64bit':
	bits = '64'
else:
	bits = '32'

# Figure out the CPU architecture
arch = None
if re.match('^i\d86$|^x86$|^x86_32$', platform.machine()):
	arch = 'x86_32'
elif platform.machine() == 'x86_64':
	arch = 'x86_64'
else:
	early_exit("Unknown architecture: " + platform.machine() + " .")


# Figure out how to clear the terminal
if platform.system() == 'Windows':
	terminal_clear = 'cls'
else:
	terminal_clear = 'clear'

# FIXME: Have this look for stty first then try the registry
# Figure out the terminal width
if platform.system() == 'Windows':
	import _winreg
	key = _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, r"Console")
	val = _winreg.QueryValueEx(key, "ScreenBufferSize")
	_winreg.CloseKey(key)
	size = hex(val[0])
	terminal_width = int('0x' + size[-4 : len(size)], 16)
else:
	terminal_width = int(os.popen('stty size', 'r').read().split()[1])

def to_native(command):
	if platform.system() == 'Windows':
		# Remove starting ./
		if command.startswith('./'):
			command = command[2 :]
		# Replace ${BLAH} with %BLAH%
		command = command.replace('${', '%').replace('}', '%')
			
	return command

def get_normal_user_name():
	# Get the name from the environmental variable
	user_name = \
		os.getenv('SUDO_USER') or \
		os.getenv('USER') or \
		os.getenv('LOGNAME')

	# Make sure we got a name
	if not user_name:
		print_exit('Failed to get the normal user name.')

	return user_name

def get_normal_user_id():
	user_name = get_normal_user_name()
	return int(os.popen('id -u {0}'.format(user_name)).read())


def do_as_normal_user(cb):
	prev_id = -1

	# Change the user to the normal user
	if platform.system() != 'Windows':
		prev_id = os.geteuid()
		user_id = get_normal_user_id()
		os.setegid(user_id)
		os.seteuid(user_id)

	# Run the cb as the normal user
	exception = False
	is_exiting = False
	try:
		cb()
	except SystemExit as err:
		# Don't save any exit() exceptions. Just exit
		is_exiting = True
	except Exception as err:
		exception = traceback.format_exc()
	except StandardError as err:
		exception = traceback.format_exc()
	except BaseException as err:
		exception = traceback.format_exc()
	finally:
		# Return the user to normal
		if platform.system() != 'Windows':
			os.setegid(prev_id)
			os.seteuid(prev_id)

	if is_exiting:
		exit()
	if exception:
		print_exit(exception)

class bcolors:
	MESSAGE = '\033[44m\033[37m'
	OK = '\033[42m\033[37m'
	FAIL = '\033[41m\033[37m'
	ENDC = '\033[0m'

def terminal_pad(length, pad_char=' '):
	width = terminal_width

	if length > (width-3):
		i = int(width * (int(length / width) + 1)) - 3
	else:
		i = width - 3
	return ''.ljust(i-length, pad_char)

def print_info(message):
	sys.stdout.write(bcolors.MESSAGE + message + bcolors.ENDC + "\n")
	sys.stdout.flush()

def print_status(message):
	global message_length
	message = '{0} ...'.format(message)
	message_length = len(message)

	sys.stdout.write(message)
	sys.stdout.flush()

def print_ok():
	global message_length
	message = terminal_pad(message_length) + bcolors.OK + ":)" + bcolors.ENDC + "\n"
	message_length = 0

	sys.stdout.write(message)
	sys.stdout.flush()

def print_fail(post_fail_message=None):
	global message_length
	message = terminal_pad(message_length, '.') + bcolors.FAIL + ":(" + bcolors.ENDC + "\n"
	if post_fail_message:
		message += post_fail_message + "\n"
	message_length = 0

	sys.stdout.write(message)
	sys.stdout.flush()

def print_exit(message):
	message = bcolors.FAIL + message + ' Exiting ...' + bcolors.ENDC + '\n'

	sys.stdout.write(message)
	sys.stdout.flush()
	exit()

class ProcessRunner(object):
	def __init__(self, command):
		self._command = to_native(command)
		self._process = None
		self._return_code = None
		self._stdout = None
		self._stderr = None
		self._status = None

	def run(self):
		self._process = subprocess.Popen(
			self._command, 
			stderr = subprocess.PIPE, 
			stdout = subprocess.PIPE, 
			shell = True, 
			env = os.environ.copy()
		)

	def wait(self):
		# Wait for the process to exit
		self._process.wait()

		# Get the return code
		self._return_code = self._process.returncode

		# Get the standard out and error text
		self._stderr  = self._process.stderr.read().rstrip()
		self._stdout = self._process.stdout.read().rstrip()
		try:
			self._stderr = str(self._stderr, 'UTF-8')
		except Exception as err:
			pass
		try:
			self._stdout = str(self._stdout, 'UTF-8')
		except Exception as err:
			pass

		# :( Failure
		if self._return_code:
			self._status = ':('
		# :) Success
		if not self._return_code:
			self._status = ':)'

	def get_is_done(self):
		# You have to poll a process to update the retval. Even if it has stopped already
		if self._process.returncode == None:
			self._process.poll()
		return self._process.returncode != None
	is_done = property(get_is_done)

	def get_is_success(self):
		self._require_wait()
		return self._status == ':)'
	is_success = property(get_is_success)

	def get_is_failure(self):
		self._require_wait()
		return self._status == ':('
	is_failure = property(get_is_failure)

	def get_stderr(self):
		self._require_wait()
		return self._stderr
	stderr = property(get_stderr)

	def get_stdout(self):
		self._require_wait()
		return self._stdout
	stdout = property(get_stdout)

	def get_stdall(self):
		self._require_wait()
		return self._stdout + '\n' + self._stderr
	stdall = property(get_stdall)

	def _require_wait(self):
		if self._return_code == None:
			raise Exception("Wait needs to be called before any info on the process can be gotten.")


class Event(object):
	is_parallel = False
	is_first_parallel = False
	events = []

	def __init__(self, task, result, plural, singular, command, setup_cb):
		self._status = 'ready'
		self._runner = None

		self._task = task
		self._result = result
		self._plural = plural
		self._singular = singular
		self._command = command
		self._setup_cb = setup_cb

	def get_is_done(self):
		return self._runner.is_done
	is_done = property(get_is_done)

	def run(self):
		global message_length

		# Show the parallel header
		if Event.is_parallel:
			if Event.is_first_parallel:
				Event.is_first_parallel = False
				sys.stdout.write("{0} {1} in parallel ...\n".format(self._task, self._plural))
				sys.stdout.flush()
				message_length = 0

		# Run the setup function
		if not self._setup_cb():
			return False

		# Show the serial message
		if not Event.is_parallel:
			print_status("{0} {1} '{2}'".format(self._task, self._singular, self._result))

		# Start the process
		self._runner = ProcessRunner(self._command)
		self._status = 'running'
		self._runner.run()
		return True

	def wait(self):
		# Wait for the process to complete
		self._runner.wait()

		# Display the message
		if Event.is_parallel:
			print_status("   '{0}'".format(self._result))

		# Success or failure
		if self._runner.is_success:
			print_ok()
			self._status = 'success'
		else:
			print_fail(self._runner.stderr)
			print_exit("{0} failed. Try again.".format(self._task))
			self._status = 'failure'

def add_event(event):
	Event.events.append(event)

	# If not parallel, run the event now
	if not Event.is_parallel:
		parallel_end()

def parallel_start():
	Event.is_parallel = True
	Event.is_first_parallel = True

def parallel_end():
	global cpus_total
	global cpus_free

	ready_events = Event.events
	running_events = []

	while len(ready_events) or len(running_events):
		# Check for events that are done
		for event in running_events[:]:
			# Check if it is done
			if event.is_done:
				event.wait()

			# Success. Keep going
			if event._status == 'success':
				running_events.remove(event)
				cpus_free += 1
			# Failure. Stop events and exit
			elif event._status == 'failure':
				print_exit("Event failed.")

		# Check for events that need to start
		while cpus_free > 0 and len(ready_events):
			event = ready_events.pop()
			if event.run():
				cpus_free -= 1
				running_events.insert(0, event)

		# Sleep if all the cpu cores are busy, or have already started
		if cpus_free == 0 or len(ready_events) == 0:
			time.sleep(0.1)

	# Clear all the events
	Event.events = []
	Event.is_parallel = False
	Event.is_first_parallel = False

def require_root():
	is_root = False

	# Windows
	if platform.system() == 'Windows':
		try:
			# Only Admin can read the C:\windows\temp
			sys_root = os.environ.get('SystemRoot','C:\windows')
			temp = os.listdir(os.path.join(sys_root, 'temp'))
			is_root = True
		except:
			pass
	# Linux / Unix
	elif os.getuid() == 0:
		is_root = True

	# Make sure we are root
	if not is_root:
		print_exit("Must be run as root.")

def require_not_root():
	# On Windows it does not matter if we are root. So just return
	if platform.system() == 'Windows':
		return
	
	# Make sure we are NOT root
	if os.getuid() == 0:
		print_exit("Must not be run as root.")

def call_on_exit(cb):
	# Set a cleanup function to run on exit
	if cb:
		atexit.register(cb)

# FIXME: Rename to run_print
def run_say(command):
	print_status("Running command")

	runner = ProcessRunner(command)
	runner.run()
	runner.wait()

	if runner.is_success:
		print_ok()
		print(command)
		print(runner.stdall)
	elif runner.is_failure:
		print_fail()
		print(command)
		print(runner.stdall)
		print_exit('Failed to run command.')

def is_outdated(to_update, triggers):
	# Make sure all the triggers exist
	for trigger in triggers:
		if not os.path.isfile(os.path.abspath(trigger)):
			print_fail()
			print_exit("The file '" + trigger + "' does not exist.")

	# Rebuild if any of the files to check do not exist
	for update in to_update:
		if not os.path.isfile(os.path.abspath(update)):
			return True

	# Get the modify date of the newest trigger file and file to check
	s, b = 0, 0
	for trigger in triggers:
		t = os.path.getmtime(trigger)
		if t > s:
			s = t
	for update in to_update:
		t = os.path.getmtime(update)
		if t > b:
			b = t

	# Rebuild if a trigger is newer than the newest file to check
	if s > b:
		return True
	else:
		return False

def _do_on_fail_exit(start_message, fail_message, cb):
	print_status(start_message)

	# Run it if it is a function
	if hasattr(cb, '__call__'):
		try:
			cb()
			print_ok()
		except Exception as e:
			print_fail()
			print_exit(fail_message)
	# Or run it as a process if a string
	elif type(cb) == str:
		runner = ProcessRunner(cb)
		runner.run()
		runner.wait()
		if runner.is_success:
			print_ok()
		elif runner.is_failure:
			print_fail()
			print_exit(fail_message)

def _do_on_fail_pass(start_message, cb):
	print_status(start_message)
	try:
		cb()
	except Exception as e:
		pass
	print_ok()

def cd(name):
	_do_on_fail_exit("Changing to dir '{0}'".format(name),
					"Failed to change to the dir '{0}'.".format(name),
				lambda: os.chdir(name))

def mvfile(source, dest):
	_do_on_fail_exit("Moving the file '{0}' to '{1}'".format(source, dest),
					"Failed to move the file' {0}'.".format(source),
				lambda: shutil.move(source, dest))

def cpfile(source, dest):
	_do_on_fail_exit("Copying the file '{0}' to '{1}'".format(source, dest),
					"Failed to copy the file '{0}' to '{1}'.".format(source, dest),
				lambda: shutil.copy2(source, dest))

def cp_new_file(source, dest):
	if not os.path.isfile(os.path.abspath(dest)):
		cpfile(source, dest)
	elif not filecmp.cmp(source, dest):
		cpfile(source, dest)

def cpdir(source, dest, symlinks = False):
	_do_on_fail_exit("Copying the dir '{0}' to '{1}'".format(source, dest),
					"Failed to copy the dir '{0}' to '{1}'.".format(source, dest),
				lambda: shutil.copytree(source, dest, symlinks = symlinks))

def mkdir_f(source):
	_do_on_fail_pass("Making the dir '{0}'".format(source),
				lambda: os.mkdir(source))

def mkdir(source):
	_do_on_fail_exit("Making the dir '{0}'".format(source),
					"Failed to make the dir '{0}'.".format(source),
				lambda: os.mkdir(source))

def rmdir_and_children(name):
	print_status("Removing the dir '{0}'".format(name))

	# Make sure we are not removing the current directory
	if name == os.getcwd():
		print_fail()
		print_exit("Can't remove the current directory '{0}'.".format(name))

	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isdir(name):
			shutil.rmtree(name)
		print_ok()
	except OSError as e:
		if 'No such file or directory' in e:
			print_ok()
			return
		print_fail()
		print_exit("Failed to remove the dir '{0}'.".format(name))

def rmdir(name):
	print_status("Removing the dir '{0}'".format(name))

	# Make sure we are not removing the current directory
	if name == os.getcwd():
		print_fail()
		print_exit("Can't remove the current directory '{0}'.".format(name))

	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isdir(name):
			os.rmdir(name)
	except OSError as e:
		if 'Directory not empty' in e:
			pass
		elif 'No such file or directory' in e:
			pass
		else:
			print_fail()
			print_exit("Failed to remove the dir '{0}'.".format(name))

	print_ok()

def rmfile(name):
	print_status("Removing the file '{0}'".format(name))
	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isfile(name):
			os.remove(name)
		print_ok()
	except Exception as e:
		print_fail()
		print_exit("Failed to remove the file '{0}'.".format(name))

def rmfile_f(name):
	print_status("Removing the file '{0}'".format(name))
	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isfile(name):
			os.remove(name)
	except Exception as e:
		pass

	print_ok()

def symlink(source, link_name):
	_do_on_fail_exit("Symlinking '{0}' to '{1}'".format(source, link_name),
					"Failed linking '{0}' to '{1}'.".format(source, link_name),
				lambda: os.symlink(source, link_name))

def ldconfig():
	# Setup the message
	print_status("Running 'ldconfig'")

	# Run the process
	runner = ProcessRunner("ldconfig")
	runner.run()
	runner.wait()

	# Success or failure
	if runner.is_failure:
		print_failure(runner.stdall)
		print_exit("Failed run 'ldconfig'.")
	elif runner.is_success:
		print_ok()

def updatedb():
	# Setup the message
	print_status("Running 'updatedb'")

	command = None
	# Updatedb on BSD and OSX
	if os.path.exists('/usr/libexec/locate.updatedb'):
		command = '/usr/libexec/locate.updatedb'
	# Updatedb on Linux
	else:
		command = 'updatedb'

	# Run the process
	runner = ProcessRunner(command)
	runner.run()
	runner.wait()

	# Success or failure
	if runner.is_failure:
		print_failure(runner.stdall)
		print_exit("Failed run 'updatedb'.")
	elif runner.is_success:
		print_ok()

# Returns all the paths that libraries are installed in
def _get_library_paths():
	paths = ['/usr/lib']
	if not os.path.exists('/etc/ld.so.conf.d/'):
		return paths

	for file_name in os.listdir('/etc/ld.so.conf.d/'):
		f = open('/etc/ld.so.conf.d/' + file_name, 'r')
		for path in f.readlines():
			path = path.strip()
			if os.path.exists(path) and not path in paths:
				paths.append(path)

	return paths

# Returns the full path of a library file or None
def _get_library_path(lib_name, extension):
	lib_name += extension
	for path in _get_library_paths():
		for dirs, subdirs, files in os.walk(path):
			for f in files:
				file_name = lib_name.split('/')[-1]
				path_end = lib_name[0:-(len(file_name)+1)]
				if dirs.endswith(path_end) and f == file_name:
					return os.path.join(dirs, file_name)

	return None

# Returns true if a library is installed
def _is_library_installed(lib_name, extension):
	if _get_library_path(lib_name, extension):
		return True
	else:
		return False

# Returns the full path of a library file or throws and exception
def _library_path(lib_name, extension):
	path = _get_library_path(lib_name, extension)
	if path:
		return path
	else:
		raise Exception("Library '{0}' not found.".format(lib_name))

def require_static_library(lib_name):
	print_status("Checking for static library '{0}'".format(lib_name))
	is_installed = _is_library_installed(lib_name, '.a')

	# Make them install the lib to continue
	if not is_installed:
		print_fail()
		print_exit("Static library '{0}' not installed. Install and try again.".format(lib_name))

	# Make them run updatedb if the library is not found by locate
	runner = ProcessRunner("locate /{0}.a".format(lib_name))
	runner.run()
	runner.wait()
	if runner.is_success:
		print_ok()
	elif runner.is_failure:
		print_fail()
		print_exit("Static library '{0}' not found with 'locate'. Run 'sudo updatedb' and try again.".format(lib_name))

def require_shared_library(lib_name):
	print_status("Checking for shared library '{0}'".format(lib_name))
	is_installed = _is_library_installed(lib_name, '.so')

	# Make them install the lib to continue
	if not is_installed:
		print_fail()
		print_exit("Shared library '{0}' not installed. Install and try again.".format(lib_name))

	# Make them run ldconfig if the library is not found by ld
	f = tempfile.NamedTemporaryFile(delete=False)
	f.close()
	runner = ProcessRunner("ld -l " + lib_name.lstrip('lib') + ' -o ' + f.name)
	runner.run()
	runner.wait()
	os.unlink(f.name)
	if runner.is_success:
		print_ok()
	elif runner.is_failure:
		print_fail()
		print_exit("Shared library '{0}' not found with 'ld'. Run 'sudo ldconfig' and try again.".format(lib_name))

def require_static_or_shared_library(lib_name):
	print_status("Checking for static/shared library '{0}'".format(lib_name))
	is_static_installed = _is_library_installed(lib_name, '.a')
	is_shared_installed = _is_library_installed(lib_name, '.so')

	# Make them install the lib to continue
	if not is_static_installed and not is_shared_installed:
		print_fail()
		print_exit("Static/Shared library '{0}' not installed. Install and try again.".format(lib_name))

	# Make them run updatedb if the library is not found by locate
	if is_static_installed:
		runner = ProcessRunner("locate /" + lib_name + ".a")
		runner.run()
		runner.wait()
		if runner.is_success:
			print_ok()
		elif runner.is_failure:
			print_fail()
			print_exit("Static library '{0}' not found with 'locate'. Run 'sudo updatedb' and try again.".format(lib_name))
		return

	# Make them run ldconfig if the library is not found by ld
	if is_shared_installed:
		f = tempfile.NamedTemporaryFile(delete=False)
		f.close()
		runner = ProcessRunner("ld -l " + lib_name.lstrip('lib') + ' -o ' + f.name)
		runner.run()
		runner.wait()
		os.unlink(f.name)
		if runner.is_success:
			print_ok()
		elif runner.is_failure:
			print_fail()
			print_exit("Shared library '{0}' not found with 'ld'. Run 'sudo ldconfig' and try again.".format(lib_name))

def require_static_libraries(lib_names):
	for lib_name in lib_names:
		require_static_library(lib_name)

def require_shared_libraries(lib_names):
	for lib_name in lib_names:
		require_shared_library(lib_name)

def require_static_or_shared_libraries(lib_names):
	for lib_name in lib_names:
		require_static_or_shared_library(lib_name)

def require_raise_dependencies():
	# Get a list of all the programs raise uses
	prog_names = [
		'which', 'locate', 
		'gcc', 'ar', 'ld'
	]
	
	# Updatedb on BSD and OSX
	if os.path.exists('/usr/libexec/locate.updatedb'):
		prog_names.append('/usr/libexec/locate.updatedb')
	# Updatedb on Linux
	else:
		prog_names.append('updatedb')

	# See which programs are not installed
	fails = []
	for prog_name in prog_names:
		runner = ProcessRunner('which {0}'.format(prog_name))
		runner.run()
		runner.wait()
		if runner.is_failure:
			fails.append(prog_name)

	# Print them in a list then exit
	if fails:
		print_info("Raise is checking for its dependencies")
		for f in fails:
			print_status("Checking for program '{0}'".format(f))
			print_fail()
		print_exit("Install the dependencies '{0}' and try again.".format(str.join("', '", fails)))

def require_programs(prog_names):
	for prog_name in prog_names:
		_do_on_fail_exit(
			"Checking for program '{0}'".format(prog_name),
			"Install the program '{0}' and try again.".format(prog_name),
			'which {0}'.format(prog_name)
		)

def require_python_modules(mod_names):
	for mod_name in mod_names:
		_do_on_fail_exit(
			"Checking for python module '{0}'".format(mod_name),
			"Install the python module '{0}' and try again.".format(mod_name),
			'{0} -c "import {1}"'.format(python, mod_name)
		)

def header_path(header_name):
	retval = None

	runner = ProcessRunner('locate /' + header_name)
	runner.run()
	runner.wait()

	if runner.is_success:
		# Get any paths that contain the library name
		paths = runner.stdout.split('\n')

		# First match paths that contain the architecture
		for path in paths:
			if 'lib' + bits in path or arch in path:
				retval = path

		# If none were matched specifically from the architecture
		# Use the first
		if retval == None:
			retval = paths[0]

	# Make sure a header file was found
	if not retval or not os.path.exists(retval):
		raise Exception("Header file not found: '" + header_name + "'")

	i = retval.rfind('/') + 1
	return retval[:i]

def header_paths(header_names):
	paths = []
	for header_name in header_names:
		paths.append(header_path(header_name))

	return paths

def include_path(header_name):
	return '-I' + header_path(header_name)

def include_paths(header_names):
	paths = []
	for header_name in header_names:
		paths.append(include_path(header_name))
	return str.join(' ', paths)

def shared_library_path(lib_name):
	return _library_path(lib_name, '.so')

def static_library_path(lib_name):
	return _library_path(lib_name, '.a')

def static_or_shared_library_path(lib_name):
	try:
		return static_library_path(lib_name)
	except Exception as e:
		pass

	try:
		return shared_library_path(lib_name)
	except Exception as e:
		pass

	raise Exception("Static/Shared library not found: '" + lib_name + "'")

def link_shared_path(lib_name):
	return '-L' + shared_library_path(lib_name)

def link_static_path(lib_name):
	return '-L' + static_library_path(lib_name)

def link_static_or_shared_path(lib_name):
	return '-L' + static_or_shared_library_path(lib_name)

def link_shared_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_shared_path(lib_name))
	return str.join(' ', paths)

def link_static_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_static_path(lib_name))
	return str.join(' ', paths)

def link_static_or_shared_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_static_or_shared_path(lib_name))
	return str.join(' ', paths)

def c_build_object(o_file, c_files, i_files=[]):
	# Setup the messages
	task = 'Building'
	result = o_file
	plural = 'C objects'
	singular = 'C object'
	command = "${CC} ${CFLAGS} -c -o " + o_file + ' ' + str.join(' ', c_files) + ' ' + str.join(' ', i_files)

	def setup():
		# Skip if the files have not changed since last build
		if not is_outdated(to_update = [o_file], triggers = c_files):
			return False

		# Make sure the environmental variable is set
		if not 'CC' in os.environ:
			print_fail()
			print_exit("Set the env variable 'CC' to the C compiler, and try again.")

		return True

	# Create the event
	event = Event(task, result, plural, singular, command, setup)
	add_event(event)

def c_build_program(o_file, c_files, i_files=[]):
	# Setup the messages
	task = 'Building'
	result = o_file
	plural = 'C objects'
	singular = 'C object'
	command = "${CC} ${CFLAGS} -o " + o_file + ' ' + str.join(' ', c_files) + ' ' + str.join(' ', i_files)

	def setup():
		# Make sure the environmental variable is set
		if not 'CC' in os.environ:
			print_fail()
			print_exit("Set the env variable 'CC' to the C compiler, and try again.")

		return True

	# Create the event
	event = Event(task, result, plural, singular, command, setup)
	add_event(event)


# FIXME: Rename to c_build_static_library
def ar_build_static_library(ar_file, o_files):
	# Setup the messages
	task = 'Building'
	result = ar_file
	plural = 'static libraries'
	singular = 'static library'
	command = "ar rcs " + ar_file + " " + str.join(' ', o_files)

	def setup():
		# Skip if the files have not changed since last build
		if not is_outdated(to_update = [ar_file], triggers = o_files):
			return False
		return True

	# Create the event
	event = Event(task, result, plural, singular, command, setup)
	add_event(event)

def c_build_shared_library(so_file, o_files):
	# Setup the messages
	task = 'Building'
	result = so_file
	plural = 'shared libraries'
	singular = 'shared library'
	command = "ld -G {0} -o {1}".format(str.join(' ', o_files), so_file)

	def setup():
		# Skip if the files have not changed since last build
		if not is_outdated(to_update = [so_file], triggers = o_files):
			return False
		return True

	# Create the event
	event = Event(task, result, plural, singular, command, setup)
	add_event(event)

def d_build_interface(d_file, i_files):
	message = "Building D interface file '{0}i'".format(d_file)
	#if not is_outdated(message, to_update = [d_file+'i'], triggers = [d_file]):
	#	return

	if not 'DC' in os.environ:
		print_fail()
		print_exit("Set the env variable 'DC' to the D compiler, and try again.")

	print_status(message)
	f = tempfile.NamedTemporaryFile(delete=False)
	f.close()
	command = "${DC} ${DFLAGS} -c " + d_file + " " + str.join(' ', i_files) + " -Hf" + d_file + "i -of" + f.name
	runner = ProcessRunner(command)
	runner.run()
	runner.wait()
	os.unlink(f.name)

	if runner.is_success:
		print_ok()
	elif runner.is_failure:
		print_fail(runner.stderr)
		print_exit("Build failed. Try again.")

def d_build_object(o_file, d_files, i_files, l_files=[], h_files=[]):
	message = "Building D object file '{0}'".format(o_file)
	#if not is_outdated(message, to_update = [o_file], triggers = d_files):
	#	return
	print_status(message)

	if not 'DC' in os.environ:
		print_fail()
		print_exit("Set the env variable 'DC' to the D compiler, and try again.")

	command = "${DC} ${DFLAGS} -c -of" + o_file + " " + str.join(' ', d_files) + " " + str.join(' ', i_files) + " " + str.join(' ', l_files)
	if h_files:
		command += " -H -Hdimport -Hf" + str.join(' ', h_files)

	runner = ProcessRunner(command)
	runner.run()
	runner.wait()

	if runner.is_success:
		print_ok()
	elif runner.is_failure:
		print_fail(runner.stderr)
		print_exit("Build failed. Try again.")

def d_build_shared_library(o_file, d_files, i_files, l_files=[], generate_headers=False):
	message = "Building D shared library '{0}'".format(o_file)
	#if not is_outdated(message, to_update = [o_file], triggers = d_files):
	#	return
	print_status(message)

	if not 'DC' in os.environ:
		print_fail()
		print_exit("Set the env variable 'DC' to the D compiler, and try again.")

	command = "${DC} ${DFLAGS} -shared -of" + o_file + " " + str.join(' ', d_files) + " " + str.join(' ', i_files) + " " + str.join(' ', l_files)
	if generate_headers:
		command += "  -Hdimport -H"

	runner = ProcessRunner(command)
	runner.run()
	runner.wait()

	if runner.is_success:
		print_ok()
	elif runner.is_failure:
		print_fail(runner.stderr)
		print_exit("Build failed. Try again.")

def d_build_static_library(o_file, d_files, i_files, l_files, generate_headers=False):
	print_status("Building D static library '{0}'".format(o_file))

	if not 'DC' in os.environ:
		print_fail()
		print_exit("Set the env variable 'DC' to the D compiler, and try again.")

	command = "${DC} ${DFLAGS} -lib -of" + o_file + " " + str.join(' ', d_files) + " " + str.join(' ', i_files) + " " + str.join(' ', l_files)
	if generate_headers:
		command += "  -Hdimport -H"

	runner = ProcessRunner(command)
	runner.run()
	runner.wait()

	if runner.is_success:
		print_ok()
	elif runner.is_failure:
		print_fail(runner.stderr)
		print_exit("Build failed. Try again.")

def d_build_program(out_file, inc_files, link_files=[]):
	print_status("Building D program '{0}'".format(out_file))

	if not 'DC' in os.environ:
		print_fail()
		print_exit("Set the env variable 'DC' to the D compiler, and try again.")

	command = "${DC} ${DFLAGS} -of" + out_file + ' ' + str.join(' ', inc_files) + " " + str.join(' ', link_files)

	runner = ProcessRunner(command)
	runner.run()
	runner.wait()

	if runner.is_success:
		print_ok()
	elif runner.is_failure:
		print_fail(runner.stderr)
		print_exit("Build failed. Try again.")

def load_rscript(g=globals(), l=locals()):
	# Make sure there is an rscript file
	if not os.path.isfile('rscript'):
		return None

	# Get a list of all the functions
	before = []
	for key in globals().keys():
		before.append(key)

	# Load the rscript file into this namespace
	with open('rscript', 'rb') as f:
		code = None
		try:
			code = compile(f.read(), 'rscript', 'exec')
		except Exception as e:
			print_exit(e)

		exec(code, g, l)

	# Get just the target functions
	targets = {}
	for key in globals().keys():
		if not key in before:
			if not key.startswith('_') and hasattr(globals()[key], '__call__'):
				targets[key] = globals()[key]

	return targets

if __name__ == '__main__':
	# Have all KeyboardInterrupt exceptions quit with a clean message
	def signal_handler(signal, frame):
		print_exit('Exit called by the keyboard.')
		exit()
	signal.signal(signal.SIGINT, signal_handler)

	# Clear the terminal
	os.system(terminal_clear)
	
	# Load the rscript
	targets = load_rscript()

	# Get the target function name
	target_name = str(str.join(' ', sys.argv[1:]))

	# Get a friendly list of all the targets
	target_list = []
	if targets:
		keys = list(targets.keys())
		keys.sort()
		target_list = "'" + str.join("', '", keys) + "'"

	# Exit if there is no target
	if not target_name:
		print("Raise software build tool (Version 0.2 - August 31 2013) http://launchpad.net/raise")
		print("")
		print("COMMANDS:")
		print("\t./raise update - Downloads the newest version of Raise. It will be stored in a file named \".raise_actual\" or \"raise_actual\".")
		print("")

		# Print all the targets
		if targets:
			print("TARGETS:")
			for t in targets:
				no_doc = "No docstring is provided for this target."
				print("\t./raise " + t + " - " + (targets[t].__doc__ or no_doc))
				print("")
			print_exit("No target specified. Found targets are {0}.".format(target_list))
	
	if not targets:
		print_exit("No 'rscript' file found.")

	# Exit if there is no target with that name
	if not target_name in targets:
		print_exit("No target named '{0}'. Found targets are {1}.".format(target_name, target_list))

	# Make sure all the programs we need are installed
	# FIXME: Requiring gcc, ar, ld, and ldconfig makes raise
	# gcc specific. What other linkers and archivers are used
	# with other C compilers? Clang, MS cl, et cetera
	require_raise_dependencies()

	# Try running the target
	target = targets[target_name]
	print_info("Running target '{0}'".format(target_name))
	target()


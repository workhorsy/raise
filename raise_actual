#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# This file is part of Raise.
# Raise is a small software build tool that ships with your code.
# Raise uses a MIT style license, and is hosted at http://launchpad.net/raise .
# Copyright (c) 2013, Matthew Brennan Jones <mattjones@workhorsy.org>
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
# 
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import os, sys, stat
import tempfile
import time
import filecmp
import signal
import platform, re, glob
import shutil
import atexit
import threading
import multiprocessing
import subprocess
import traceback
if sys.version_info < (3, 0):
	import urllib2
	globals()['urlopen'] = urllib2.urlopen
else:
	import urllib.request
	globals()['urlopen'] = urllib.request.urlopen


global pwd
global python
global bits
global arch
global target_name

target_name = None
g_events = []
cpus_total = multiprocessing.cpu_count() * 2
cpus_free = cpus_total

# Get the path of the rscript file
pwd = os.sys.path[0]

# Make sure we are in at least python 2.6
if sys.version_info < (2, 6):
	print_exit("Python 2.6 or greater is required.")

# Get the name of the current running python program
python = sys.executable
if not python:
	print_exit('Could not find python to run child processes with.')

# Figure out if the CPU is 32bit or 64bit
bits = None
if platform.architecture()[0] == '64bit':
	bits = '64'
else:
	bits = '32'

# Figure out the CPU architecture
arch = None
if re.match('^i\d86', platform.machine()):
	arch = 'i386'
elif platform.machine() == 'x86_64':
	arch = 'x86_64'
else:
	print_exit("Unknown architecture: " + platform.machine() + " .")


def get_normal_user_name():
	# Get the name from the environmental variable
	user_name = \
		os.getenv('SUDO_USER') or \
		os.getenv('USER') or \
		os.getenv('LOGNAME')

	# Make sure we got a name
	if not user_name:
		print_exit('Failed to get the normal user name.')

	return user_name

def get_normal_user_id():
	user_name = get_normal_user_name()
	return int(os.popen('id -u {0}'.format(user_name)).read())


class NormalUserSubProcess(multiprocessing.Process):
	"""
	Just like multiprocessing.Process, but it will run the function 
	as a normal user when run as root.
	"""
	def __init__(self, group=None, target=None, name=None, args=(), kwargs={}):
		super(NormalUserSubProcess, self).__init__(group, target, name, args, kwargs)
		self._queue = multiprocessing.Queue()

	def get_retval(self):
		return self._queue.get()

	def run(self):
		# Change the user to the normal user
		user_id = get_normal_user_id()
		os.setgid(user_id)
		os.setuid(user_id)

		# Run the cb as the normal user
		retval = {}
		retval['exception'] = None
		retval['is_exiting'] = False
		try:
			super(NormalUserSubProcess, self).run()
		except SystemExit as err:
			# Don't save any exit() exceptions. Just exit
			retval['is_exiting'] = True
		except Exception as err:
			retval['exception'] = traceback.format_exc()
		except StandardError as err:
			retval['exception'] = traceback.format_exc()
		except BaseException as err:
			retval['exception'] = traceback.format_exc()
		finally:
			self._queue.put(retval)

def do_as_normal_user(cb):
	p = NormalUserSubProcess(target=cb, args=())
	p.start()
	p.join()

	retval = p.get_retval()
	if retval['is_exiting']:
		exit()
	if retval['exception']:
		print_exit(retval['exception'])

class bcolors:
	MESSAGE = '\033[44m\033[37m'
	OK = '\033[42m\033[37m'
	FAIL = '\033[41m\033[37m'
	ENDC = '\033[0m'

def terminal_pad(length, pad_char=' '):
	width = int(os.popen('stty size', 'r').read().split()[1])
	if length > (width-3):
		i = int(width * (int(length / width) + 1)) - 3
	else:
		i = width - 3
	return ''.ljust(i-length, pad_char)

def print_info(message):
	sys.stdout.write(bcolors.MESSAGE + message + bcolors.ENDC + "\n")
	sys.stdout.flush()

def print_status(message):
	message = '{0} ...'.format(message)

	t = threading.currentThread()
	if type(t) == EventThread:
		t.set_message(message)
	else:
		sys.stdout.write(message)
		sys.stdout.flush()
	return len(message)

def print_ok(length):
	message = terminal_pad(length) + bcolors.OK + ":)" + bcolors.ENDC + "\n"

	t = threading.currentThread()
	if type(t) == EventThread:
		t.append_message(message)
	else:
		sys.stdout.write(message)
		sys.stdout.flush()

def print_fail(length, post_fail_message=None):
	message = terminal_pad(length, '.') + bcolors.FAIL + ":(" + bcolors.ENDC + "\n"
	if post_fail_message:
		message += post_fail_message + "\n"

	t = threading.currentThread()
	if type(t) == EventThread:
		t.append_message(message)
	else:
		sys.stdout.write(message)
		sys.stdout.flush()

def print_exit(message):
	message = bcolors.FAIL + message + ' Exiting ...' + bcolors.ENDC + '\n'

	t = threading.currentThread()
	if type(t) == EventThread:
		t.append_message(message)
	else:
		sys.stdout.write(message)
		sys.stdout.flush()
		exit()

class EventThread(threading.Thread):
	def __init__(self, event):
		self._event = event
		threading.Thread.__init__(self)

	def is_parallel(self):
		return self._event._is_parallel

	def set_message(self, message):
		self._event._message = message

	def append_message(self, message):
		self._event._message += message

	def set_subprocess(self, subprocess):
		self._event._subprocess = subprocess

	def run(self):
		self._event._call_func()

class Event(object):
	def __init__(self, args, func, is_parallel):
		self._args = args
		self._func = func
		self._is_parallel = is_parallel
		self._status = 'ready'
		self._message = None
		self._thread = None
		self._subprocess = None

	def _call_func(self):
		if self._func(*self._args):
			self._status = 'success'
		else:
			self._status = 'failure'

	def run_async(self):
		self._status = 'running'
		self._thread = EventThread(self)
		self._thread.start()

	def wait_to_complete(self):
		if not self._thread:
			return
		self._thread.join()
		self._thread = None

	def run_sync(self):
		self.run_async()
		self.wait_to_complete()
		if self._message:
			sys.stdout.write(self._message)
			sys.stdout.flush()
		if self._status == 'failure':
			exit()

	def stop(self):
		if self._subprocess:
			try:
				os.killpg(self._subprocess.pid, signal.SIGTERM)
			except Exception as err:
				pass
		self._status = 'stopped'

def parallel_wait():
	global g_events
	global cpus_total
	global cpus_free

	ready_events = g_events
	running_events = []

	sys.stdout.write("Building C object files in parallel ...\n")
	sys.stdout.flush()
	while len(ready_events) or len(running_events):
		# Check for events that are done
		all_done = True
		for event in running_events:
			# Print any message if done
			if event._status in ['success', 'failure']:
				if event._message:
					sys.stdout.write(event._message)
					sys.stdout.flush()

			# Success. Keep going
			if event._status == 'success':
				event._status = 'done'
				cpus_free += 1
			# Failure. Stop events and exit
			elif event._status == 'failure':
				for event in running_events:
					event.stop()
					event.wait_to_complete()
				exit()
			# Not done. Keep going
			elif event._status != 'done':
				all_done = False

		# Check for events that need to start
		while cpus_free > 0 and len(ready_events):
			event = ready_events.pop()
			cpus_free -= 1
			event.run_async()
			running_events.insert(0, event)
			all_done = False

		# If they all are done, wait for them to exit then return
		if all_done:
			for event in running_events:
				event.wait_to_complete()
			running_events = []

		# Sleep if all the cpu cores are busy, or have already started
		if cpus_free == 0 or len(ready_events) == 0:
			time.sleep(0.1)

	# Clear all the events
	g_events = []

def require_root():
	# Make sure we are root
	if run_sync('whoami') != 'root':
		print_exit("Must be run as root.")

def require_not_root():
	# Make sure we are NOT root
	if run_sync('whoami') == 'root':
		print_exit("Must not be run as root.")

def call_on_exit(cb):
	# Set a cleanup function to run on exit
	if cb:
		atexit.register(cb)

def run_sync(command):
	p = run_async(command)
	p.wait()
	return _run_get_output(p)

def run_async(command):
	p = subprocess.Popen(command, stderr=subprocess.PIPE, stdout=subprocess.PIPE, shell=True, preexec_fn=os.setsid)
	return p

def _run_get_output(p):
	e = p.stderr.read().rstrip()
	o = p.stdout.read().rstrip()
	try:
		e = str(e, 'UTF-8')
	except Exception as err:
		pass
	try:
		o = str(o, 'UTF-8')
	except Exception as err:
		pass

	if p.returncode:
		if len(e) != 0:
			raise Exception(e)
		else:
			raise Exception(o)

	return o

# FIXME: Rename to run_print
def run_say(command):
	message = "Running command ..."
	length = len(message)
	sys.stdout.write(message)
	sys.stdout.flush()
	p = subprocess.Popen(command, stderr=subprocess.PIPE, stdout=subprocess.PIPE, shell=True, preexec_fn=os.setsid)
	p.wait()
	o = p.stdout.read().rstrip()
	e = p.stderr.read().rstrip()
	try:
		e = str(e, 'UTF-8')
	except Exception as err:
		pass
	try:
		o = str(o, 'UTF-8')
	except Exception as err:
		pass

	if p.returncode:
		print_fail(length)
		if len(o):
			print(o)
		if len(e):
			print(e)
		print_exit('Failed to run command.')
	else:
		print_ok(length)
		if len(o):
			print(o)
		if len(e):
			print(e)

def is_outdated(message, to_update, triggers):
	# Make sure all the triggers exist
	for trigger in triggers:
		if not os.path.isfile(os.path.abspath(trigger)):
			length = print_status(message)
			print_fail(length)
			print_exit("The file '" + trigger + "' does not exist.")

	# Rebuild if any of the files to check do not exist
	for update in to_update:
		if not os.path.isfile(os.path.abspath(update)):
			return True

	# Get the modify date of the newest trigger file and file to check
	s, b = 0, 0
	for trigger in triggers:
		t = os.path.getmtime(trigger)
		if t > s:
			s = t
	for update in to_update:
		t = os.path.getmtime(update)
		if t > b:
			b = t

	# Rebuild if a trigger is newer than the newest file to check
	if s > b:
		return True
	else:
		return False

def _do_on_fail_exit(start_message, fail_message, cb):
	length = print_status(start_message)
	try:
		cb()
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print_exit(fail_message)

def _do_on_fail_pass(start_message, cb):
	length = print_status(start_message)
	try:
		cb()
	except Exception as e:
		pass
	print_ok(length)

def cd(name):
	_do_on_fail_exit("Changing to dir '{0}'".format(name),
					"Failed to change to the dir '{0}'.".format(name),
				lambda: os.chdir(name))

def mvfile(source, dest):
	_do_on_fail_exit("Moving the file '{0}' to '{1}'".format(source, dest),
					"Failed to move the file' {0}'.".format(source),
				lambda: shutil.move(source, dest))

def cpfile(source, dest):
	_do_on_fail_exit("Copying the file '{0}' to '{1}'".format(source, dest),
					"Failed to copy the file '{0}' to '{1}'.".format(source, dest),
				lambda: shutil.copy2(source, dest))

def cp_new_file(source, dest):
	if not os.path.isfile(os.path.abspath(dest)):
		cpfile(source, dest)
	elif not filecmp.cmp(source, dest):
		cpfile(source, dest)

def cpdir(source, dest, symlinks = False):
	_do_on_fail_exit("Copying the dir '{0}' to '{1}'".format(source, dest),
					"Failed to copy the dir '{0}' to '{1}'.".format(source, dest),
				lambda: shutil.copytree(source, dest, symlinks = symlinks))

def mkdir_f(source):
	_do_on_fail_pass("Making the dir '{0}'".format(source),
				lambda: os.mkdir(source))

def mkdir(source):
	_do_on_fail_exit("Making the dir '{0}'".format(source),
					"Failed to make the dir '{0}'.".format(source),
				lambda: os.mkdir(source))

def rmdir_and_children(name):
	length = print_status("Removing the dir '{0}'".format(name))

	# Make sure we are not removing the current directory
	if name == os.getcwd():
		print_fail(length)
		print_exit("Can't remove the current directory '{0}'.".format(name))

	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isdir(name):
			shutil.rmtree(name)
		print_ok(length)
	except OSError as e:
		if 'No such file or directory' in e:
			print_ok(length)
			return
		print_fail(length)
		print_exit("Failed to remove the dir '{0}'.".format(name))

def rmdir(name):
	length = print_status("Removing the dir '{0}'".format(name))

	# Make sure we are not removing the current directory
	if name == os.getcwd():
		print_fail(length)
		print_exit("Can't remove the current directory '{0}'.".format(name))

	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isdir(name):
			os.rmdir(name)
	except OSError as e:
		if 'Directory not empty' in e:
			pass
		elif 'No such file or directory' in e:
			pass
		else:
			print_fail(length)
			print_exit("Failed to remove the dir '{0}'.".format(name))

	print_ok(length)

def rmfile(name):
	length = print_status("Removing the file '{0}'".format(name))
	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isfile(name):
			os.remove(name)
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print_exit("Failed to remove the file '{0}'.".format(name))

def rmfile_f(name):
	length = print_status("Removing the file '{0}'".format(name))
	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isfile(name):
			os.remove(name)
	except Exception as e:
		pass

	print_ok(length)

def symlink(source, link_name):
	_do_on_fail_exit("Symlinking '{0}' to '{1}'".format(source, link_name),
					"Failed linking '{0}' to '{1}'.".format(source, link_name),
				lambda: os.symlink(source, link_name))

def ldconfig():
	_do_on_fail_exit("Running 'ldconfig'",
					"Failed run 'ldconfig'.",
				lambda: run_sync('ldconfig'))

def updatedb():
	_do_on_fail_exit("Running 'updatedb'",
					"Failed run 'updatedb'.",
				lambda: run_sync('updatedb'))

# Returns all the paths that libraries are installed in
def _get_library_paths():
	paths = ['/usr/lib']
	for file_name in os.listdir('/etc/ld.so.conf.d/'):
		f = open('/etc/ld.so.conf.d/' + file_name, 'r')
		for path in f.readlines():
			path = path.strip()
			if os.path.exists(path) and not path in paths:
				paths.append(path)

	return paths

# Returns the full path of a library file or None
def _get_library_path(lib_name, extension):
	lib_name += extension
	for path in _get_library_paths():
		for dirs, subdirs, files in os.walk(path):
			for f in files:
				file_name = lib_name.split('/')[-1]
				path_end = lib_name[0:-(len(file_name)+1)]
				if dirs.endswith(path_end) and f == file_name:
					return os.path.join(dirs, file_name)

	return None

# Returns true if a library is installed
def _is_library_installed(lib_name, extension):
	if _get_library_path(lib_name, extension):
		return True
	else:
		return False

# Returns the full path of a library file or throws and exception
def _library_path(lib_name, extension):
	path = _get_library_path(lib_name, extension)
	if path:
		return path
	else:
		raise Exception("Library '{0}' not found.".format(lib_name))

def require_static_library(lib_name):
	length = print_status("Checking for static library '{0}'".format(lib_name))
	is_installed = _is_library_installed(lib_name, '.a')

	# Make them install the lib to continue
	if not is_installed:
		print_fail(length)
		print_exit("Static library '{0}' not installed. Install and try again.".format(lib_name))

	# Make them run updatedb if the library is not found by locate
	try:
		run_sync("locate /" + lib_name + ".a")
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print_exit("Static library '{0}' not found with 'locate'. Run 'sudo updatedb' and try again.".format(lib_name))

def require_shared_library(lib_name):
	length = print_status("Checking for shared library '{0}'".format(lib_name))
	is_installed = _is_library_installed(lib_name, '.so')

	# Make them install the lib to continue
	if not is_installed:
		print_fail(length)
		print_exit("Shared library '{0}' not installed. Install and try again.".format(lib_name))

	# Make them run ldconfig if the library is not found by ld
	f = tempfile.NamedTemporaryFile(delete=False)
	f.close()
	try:
		run_sync("ld -l " + lib_name.lstrip('lib') + ' -o ' + f.name)
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print_exit("Shared library '{0}' not found with 'ld'. Run 'sudo ldconfig' and try again.".format(lib_name))
	finally:
		os.unlink(f.name)

def require_static_or_shared_library(lib_name):
	length = print_status("Checking for static/shared library '{0}'".format(lib_name))
	is_static_installed = _is_library_installed(lib_name, '.a')
	is_shared_installed = _is_library_installed(lib_name, '.so')

	# Make them install the lib to continue
	if not is_static_installed and not is_shared_installed:
		print_fail(length)
		print_exit("Static/Shared library '{0}' not installed. Install and try again.".format(lib_name))

	# Make them run updatedb if the library is not found by locate
	if is_static_installed:
		try:
			run_sync("locate /" + lib_name + ".a")
			print_ok(length)
			return
		except Exception as e:
			print_fail(length)
			print_exit("Static library '{0}' not found with 'locate'. Run 'sudo updatedb' and try again.".format(lib_name))

	# Make them run ldconfig if the library is not found by ld
	if is_shared_installed:
		f = tempfile.NamedTemporaryFile(delete=False)
		f.close()
		try:
			run_sync("ld -l " + lib_name.lstrip('lib') + ' -o ' + f.name)
			print_ok(length)
		except Exception as e:
			print_fail(length)
			print_exit("Shared library '{0}' not found with 'ld'. Run 'sudo ldconfig' and try again.".format(lib_name))
		finally:
			os.unlink(f.name)

def require_static_libraries(lib_names):
	for lib_name in lib_names:
		require_static_library(lib_name)

def require_shared_libraries(lib_names):
	for lib_name in lib_names:
		require_shared_library(lib_name)

def require_static_or_shared_libraries(lib_names):
	for lib_name in lib_names:
		require_static_or_shared_library(lib_name)

def require_raise_dependencies(prog_names):
	fails = []
	# See which programs are not installed
	for prog_name in prog_names:
		cb = lambda: run_sync('which {0}'.format(prog_name))
		try:
			cb()
		except Exception as e:
			fails.append(prog_name)

	# Print them in a list then exit
	if fails:
		print_info("Raise is checking for its dependencies")
		for f in fails:
			length = print_status("Checking for program '{0}'".format(f))
			print_fail(length)
		print_exit("Install the dependencies '{0}' and try again.".format(str.join("', '", fails)))

def require_programs(prog_names):
	for prog_name in prog_names:
		_do_on_fail_exit("Checking for program '{0}'".format(prog_name),
				"Install the program '{0}' and try again.".format(prog_name),
				lambda: run_sync('which {0}'.format(prog_name)))

def require_python_modules(mod_names):
	for mod_name in mod_names:
		_do_on_fail_exit("Checking for python module '{0}'".format(mod_name),
						"Install the python module '{0}' and try again.".format(mod_name),
					lambda: run_sync('{0} -c "import {1}"'.format(python, mod_name)))

def header_path(header_name):
	retval = None
	try:
		# Get any paths that contain the library name
		paths = run_sync('locate /' + header_name).split('\n')

		# First match paths that contain the architecture
		for path in paths:
			if 'lib' + bits in path or arch in path:
				retval = path

		# If none were matched specifically from the architecture
		# Use the first
		if retval == None:
			retval = paths[0]
	except Exception as e:
		pass

	if not retval or not os.path.exists(retval):
		raise Exception("Header file not found: '" + header_name + "'")

	i = retval.rfind('/') + 1
	return retval[:i]

def header_paths(header_names):
	paths = []
	for header_name in header_names:
		paths.append(header_path(header_name))

	return paths

def include_path(header_name):
	return '-I' + header_path(header_name)

def include_paths(header_names):
	paths = []
	for header_name in header_names:
		paths.append(include_path(header_name))
	return str.join(' ', paths)

def shared_library_path(lib_name):
	return _library_path(lib_name, '.so')

def static_library_path(lib_name):
	return _library_path(lib_name, '.a')

def static_or_shared_library_path(lib_name):
	try:
		return static_library_path(lib_name)
	except Exception as e:
		pass

	try:
		return shared_library_path(lib_name)
	except Exception as e:
		pass

	raise Exception("Static/Shared library not found: '" + lib_name + "'")

def link_shared_path(lib_name):
	return '-L' + shared_library_path(lib_name)

def link_static_path(lib_name):
	return '-L' + static_library_path(lib_name)

def link_static_or_shared_path(lib_name):
	return '-L' + static_or_shared_library_path(lib_name)

def link_shared_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_shared_path(lib_name))
	return str.join(' ', paths)

def link_static_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_static_path(lib_name))
	return str.join(' ', paths)

def link_static_or_shared_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_static_or_shared_path(lib_name))
	return str.join(' ', paths)

def parallel_c_build_object(o_file, c_files, i_files=[]):
	global g_events
	args = [o_file, c_files, i_files]
	func = _c_build_object
	is_parallel = True
	g_events.append(Event(args, func, is_parallel))

def c_build_object(o_file, c_files, i_files=[]):
	args = [o_file, c_files, i_files]
	func = _c_build_object
	is_parallel = False
	event = Event(args, func, is_parallel)
	event.run_sync()

def _c_build_object(o_file, c_files, i_files=[]):
	t = threading.currentThread()
	if not t.is_parallel():
		message = "Building C object file '{0}'".format(o_file)
	else:
		message = "    '{0}'".format(o_file)
	if not is_outdated(message, to_update = [o_file], triggers = c_files):
		return True

	length = print_status(message)
	try:
		if not 'CC' in os.environ:
			print_fail(length)
			print_exit("Set the env variable 'CC' to the C compiler, and try again.")

		p = run_async("${CC} ${CFLAGS} -c -o " + o_file + ' ' + str.join(' ', c_files) + ' ' + str.join(' ', i_files))
		t.set_subprocess(p)
		p.wait()
		_run_get_output(p)
		print_ok(length)
		return True
	except Exception as e:
		print_fail(length, str(e))
		print_exit("Build failed. Try again.")
		return False

def c_build_program(o_file, c_files, i_files=[]):
	length = print_status("Building C program '{0}'".format(o_file))
	try:
		if not 'CC' in os.environ:
			print_fail(length)
			print_exit("Set the env variable 'CC' to the C compiler, and try again.")

		run_sync("${CC} ${CFLAGS} -o " + o_file + ' ' + str.join(' ', c_files) + ' ' + str.join(' ', i_files))
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print(e)
		print_exit("Build failed. Try again.")

# FIXME: Rename to c_build_static_library
def ar_build_static_library(ar_file, o_files):
	message = "Building static library '{0}'".format(ar_file)
	if not is_outdated(message, to_update = [ar_file], triggers = o_files):
		return

	length = print_status(message)
	try:
		run_sync("ar rcs " + ar_file + " " + str.join(' ', o_files))
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print(e)
		print_exit("Archive failed. Try again.")

def c_build_shared_library(so_file, o_files):
	message = "Building shared library '{0}'".format(so_file)
	if not is_outdated(message, to_update = [so_file], triggers = o_files):
		return

	length = print_status(message)
	try:
		command = "ld -G {0} -o {1}".format(str.join(' ', o_files), so_file)
		run_sync(command)
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print(e)
		print_exit("Building shared library failed. Try again.")

def d_build_interface(d_file, i_files):
	message = "Building D interface file '{0}i'".format(d_file)
	if not is_outdated(message, to_update = [d_file+'i'], triggers = [d_file]):
		return

	length = print_status(message)
	f = tempfile.NamedTemporaryFile(delete=False)
	f.close()
	try:
		if not 'DC' in os.environ:
			print_fail(length)
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		command = "${DC} ${DFLAGS} -c " + d_file + " " + str.join(' ', i_files) + " -Hf" + d_file + "i -of" + f.name
		run_sync(command)
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print(e)
		print_exit("Build failed. Try again.")
	finally:
		os.unlink(f.name)

def d_build_object(o_file, d_files, i_files, l_files=[], h_files=[]):
	message = "Building D object file '{0}'".format(o_file)
	if not is_outdated(message, to_update = [o_file], triggers = d_files):
		return

	length = print_status(message)
	try:
		if not 'DC' in os.environ:
			print_fail(length)
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		command = "${DC} ${DFLAGS} -c -of" + o_file + " " + str.join(' ', d_files) + " " + str.join(' ', i_files) + " " + str.join(' ', l_files)
		if h_files:
			command += " -H -Hdimport -Hf" + str.join(' ', h_files)
		run_sync(command)
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print(e)
		print_exit("Build failed. Try again.")

def d_build_shared_library(o_file, d_files, i_files, l_files=[], generate_headers=False):
	message = "Building D shared library '{0}'".format(o_file)
	if not is_outdated(message, to_update = [o_file], triggers = d_files):
		return

	length = print_status(message)
	try:
		if not 'DC' in os.environ:
			print_fail(length)
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		command = "${DC} ${DFLAGS} -shared -of" + o_file + " " + str.join(' ', d_files) + " " + str.join(' ', i_files) + " " + str.join(' ', l_files)
		if generate_headers:
			command += "  -Hdimport -H"
		run_sync(command)
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print(e)
		print_exit("Build failed. Try again.")

def d_build_static_library(o_file, d_files, i_files, l_files, generate_headers=False):
	length = print_status("Building D static library '{0}'".format(o_file))
	try:
		if not 'DC' in os.environ:
			print_fail(length)
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		command = "${DC} ${DFLAGS} -lib -of" + o_file + " " + str.join(' ', d_files) + " " + str.join(' ', i_files) + " " + str.join(' ', l_files)
		if generate_headers:
			command += "  -Hdimport -H"
		run_sync(command)
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print(e)
		print_exit("Build failed. Try again.")

def d_build_program(out_file, inc_files, link_files=[]):
	length = print_status("Building D program '{0}'".format(out_file))
	try:
		if not 'DC' in os.environ:
			print_fail(length)
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		command = "${DC} ${DFLAGS} -of" + out_file + ' ' + str.join(' ', inc_files) + " " + str.join(' ', link_files)
		run_sync(command)
		print_ok(length)
	except Exception as e:
		print_fail(length)
		print(e)
		print_exit("Build failed. Try again.")

def load_rscript(g=globals(), l=locals()):
	# Make sure there is an rscript file
	if not os.path.isfile('rscript'):
		return None

	# Get a list of all the functions
	before = []
	for key in globals().keys():
		before.append(key)

	# Load the rscript file into this namespace
	with open('rscript', 'rb') as f:
		code = None
		try:
			code = compile(f.read(), 'rscript', 'exec')
		except Exception as e:
			print_exit(e)

		exec(code, g, l)

	# Get just the target functions
	targets = {}
	for key in globals().keys():
		if not key in before:
			if not key.startswith('_') and hasattr(globals()[key], '__call__'):
				targets[key] = globals()[key]

	return targets

if __name__ == '__main__':
	# Have all KeyboardInterrupt exceptions quit with a clean message
	def signal_handler(signal, frame):
		print_exit('Exit called by the keyboard.')
		exit()
	signal.signal(signal.SIGINT, signal_handler)

	# Load the rscript
	targets = load_rscript()

	# Get the target function name
	target_name = str(str.join(' ', sys.argv[1:]))

	# Get a friendly list of all the targets
	target_list = []
	if targets:
		keys = targets.keys()
		keys.sort()
		target_list = "'" + str.join("', '", keys) + "'"

	# Exit if there is no target
	if not target_name:
		print("Raise version 0.1 (February 5 2013)")
		print("Raise is a small software build tool that ships with your code.")
		print("Copyright (c) 2013 Matthew Brennan Jones <mattjones@workhorsy.org>")
		print("Raise uses a MIT style license.")
		print("More information about Raise can be found at:")
		print("http://launchpad.net/raise")
		print("")
		print("COMMANDS:")
		print("\t./raise update - Downloads the newest version of Raise. It will be stored in a file named \".raise_actual\" or \"raise_actual\".")
		print("")

		# Print all the targets
		if targets:
			print("TARGETS:")
			for t in targets:
				no_doc = "No docstring is provided for this target."
				print("\t./raise " + t + " - " + (targets[t].__doc__ or no_doc))
				print("")
			print_exit("No target specified. Found targets are {0}.".format(target_list))
	
	if not targets:
		print_exit("No 'rscript' file found.")

	# Exit if there is no target with that name
	if not target_name in targets:
		print_exit("No target named '{0}'. Found targets are {1}.".format(target_name, target_list))

	# Make sure all the programs we need are installed
	# FIXME: Requiring gcc, ar, ld, and ldconfig makes raise
	# gcc specific. What other linkers and archivers are used
	# with other C compilers? Clang, MS cl, et cetera
	require_raise_dependencies([
		'which', 'clear', 'locate', 'whoami', 'grep', 'stty', 'updatedb',
		'gcc', 'ar', 'ld'])

	# Try running the target
	target = targets[target_name]
	print_info("Running target '{0}'".format(target_name))
	target()




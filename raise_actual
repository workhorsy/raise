#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# This file is part of Raise.
# Raise is a small software build tool that ships with your code.
# Raise uses a MIT style license, and is hosted at http://launchpad.net/raise .
# Copyright (c) 2013, Matthew Brennan Jones <mattjones@workhorsy.org>
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
# 
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import os, sys, platform
import tempfile, shutil, filecmp
import multiprocessing, subprocess
import signal, atexit
import re
import time
import traceback

global pwd
global python
global target_name
global message_length
global config
global modules
global c_compilers
global c_linkers
global d_compilers

pwd = None
python = None
target_name = None
message_length = None
config = None
modules = []
c_compilers = {}
c_linkers = {}
d_compilers = {}

def early_exit(message):
	sys.stdout.write('{0} Exiting ...\n'.format(message))
	sys.stdout.flush()
	exit()

# Make sure we are in at least python 2.6
if sys.version_info < (2, 6):
	early_exit("Python 2.6 or greater is required.")

# Get the path of the rscript file
pwd = os.sys.path[0]

# Get the name of the current running python program
python = sys.executable
if not python:
	early_exit('Could not find python to run child processes with.')

class Config(object):
	def __init__(self):
		self._cc = None
		self._dc = None
		self._clinker = None

		# Figure out the CPU architecture
		if re.match('^i\d86$|^x86$|^x86_32$|^i86pc$', platform.machine()):
			self._arch = 'x86_32'
			self._bits = '32'
		elif re.match('^x86$|^x86_64$|^amd64$', platform.machine()):
			self._arch = 'x86_64'
			self._bits = '64'
		else:
			early_exit('Unknown architecture {0}.'.format(platform.machine()))

		# Figure out how many cpus there are
		self._cpus_total = multiprocessing.cpu_count()
		self._cpus_free = self._cpus_total

		# Figure out the general OS type
		if 'cygwin' in platform.system().lower():
			self._os_type = OSType(
				name =                 'Cygwin', 
				exe_extension =        '', 
				object_extension =     '.o', 
				shared_lib_extension = '.so', 
				static_lib_extension = '.a'
			)
		elif 'windows' in platform.system().lower():
			self._os_type = OSType(
				name =                 'Windows', 
				exe_extension =        '.exe', 
				object_extension =     '.obj', 
				shared_lib_extension = '.dll', 
				static_lib_extension = '.lib'
			)
		else:
			self._os_type = OSType(
				name =                 'Unix', 
				exe_extension =        '', 
				object_extension =     '.o', 
				shared_lib_extension = '.so', 
				static_lib_extension = '.a'
			)

		# Figure out how to clear the terminal
		if self._os_type._name == 'Windows':
			self._terminal_clear = 'cls'
		else:
			self._terminal_clear = 'clear'

		# FIXME: Have this look for stty first then try the registry
		# Figure out the terminal width
		if self._os_type._name == 'Windows':
			import _winreg
			key = _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, r"Console")
			val = _winreg.QueryValueEx(key, "ScreenBufferSize")
			_winreg.CloseKey(key)
			size = hex(val[0])
			self._terminal_width = int('0x' + size[-4 : len(size)], 16)
		else:
			self._terminal_width = int(os.popen('stty size', 'r').read().split()[1])

class OSType(object):
	def __init__(self, name, exe_extension, object_extension, 
				shared_lib_extension, static_lib_extension):

		self._name = name
		self._exe_extension = exe_extension
		self._object_extension = object_extension
		self._shared_lib_extension = shared_lib_extension
		self._static_lib_extension = static_lib_extension


def get_normal_user_name():
	# Get the name from the environmental variable
	user_name = \
		os.getenv('SUDO_USER') or \
		os.getenv('USER') or \
		os.getenv('LOGNAME')

	# Make sure we got a name
	if not user_name:
		print_exit('Failed to get the normal user name.')

	return user_name

def get_normal_user_id():
	user_name = get_normal_user_name()
	return int(os.popen('id -u {0}'.format(user_name)).read())


def do_as_normal_user(cb):
	prev_id = -1

	# Change the user to the normal user
	if not config._os_type._name in ['Windows', 'Cygwin']:
		prev_id = os.geteuid()
		user_id = get_normal_user_id()
		os.setegid(user_id)
		os.seteuid(user_id)

	# Run the cb as the normal user
	exception = False
	is_exiting = False
	try:
		cb()
	except SystemExit as err:
		# Don't save any exit() exceptions. Just exit
		is_exiting = True
	except Exception as err:
		exception = traceback.format_exc()
	except StandardError as err:
		exception = traceback.format_exc()
	except BaseException as err:
		exception = traceback.format_exc()
	finally:
		# Return the user to normal
		if not config._os_type._name in ['Windows', 'Cygwin']:
			os.setegid(prev_id)
			os.seteuid(prev_id)

	if is_exiting:
		exit()
	if exception:
		print_exit(exception)

class emoticons:
	SMILE = ':)'
	NORMAL = ':\\'
	FROWN = ':('

class bcolors:
	MESSAGE = '\033[44m\033[37m'
	OK = '\033[42m\033[37m'
	WARNING = '\033[43m\033[30m'
	FAIL = '\033[41m\033[37m'
	ENDC = '\033[0m'

def terminal_pad(length, pad_char=' '):
	width = config._terminal_width

	if length > (width-3):
		i = int(width * (int(length / width) + 1)) - 3
	else:
		i = width - 3
	return ''.ljust(i-length, pad_char)

def print_info(message):
	sys.stdout.write('{0}{1}{2}\n'.format(bcolors.MESSAGE, message, bcolors.ENDC))
	sys.stdout.flush()

def print_status(message):
	global message_length
	message = '{0} ...'.format(message)
	message_length = len(message)

	sys.stdout.write(message)
	sys.stdout.flush()

def print_ok():
	global message_length

	padding = terminal_pad(message_length)
	message = "{0}{1}{2}{3}\n".format(padding, bcolors.OK, emoticons.SMILE, bcolors.ENDC)
	message_length = 0

	sys.stdout.write(message)
	sys.stdout.flush()

def print_warning(post_message=None):
	global message_length

	padding = terminal_pad(message_length, '.')
	message = "{0}{1}{2}{3}\n".format(padding, bcolors.WARNING, emoticons.NORMAL, bcolors.ENDC)
	if post_message:
		message += post_message + "\n"
	message_length = 0

	sys.stdout.write(message)
	sys.stdout.flush()

def print_fail(post_fail_message=None):
	global message_length

	padding = terminal_pad(message_length, '.')
	message = "{0}{1}{2}{3}\n".format(padding, bcolors.FAIL, emoticons.FROWN, bcolors.ENDC)
	if post_fail_message:
		message += post_fail_message + "\n"
	message_length = 0

	sys.stdout.write(message)
	sys.stdout.flush()

def print_exit(message):
	message = '{0}{1} Exiting ...{2}\n'.format(bcolors.FAIL, message, bcolors.ENDC)

	sys.stdout.write(message)
	sys.stdout.flush()
	exit()

class ProcessRunner(object):
	def __init__(self, command):
		if config._os_type._name == 'Windows':
			# Remove starting ./
			if command.startswith('./'):
				command = command[2 :]
			# Replace ${BLAH} with %BLAH%
			command = command.replace('${', '%').replace('}', '%')

		self._command = command
		self._process = None
		self._return_code = None
		self._stdout = None
		self._stderr = None
		self._status = None

	def run(self):
		self._process = subprocess.Popen(
			self._command, 
			stderr = subprocess.PIPE, 
			stdout = subprocess.PIPE, 
			shell = True, 
			env = os.environ.copy()
		)

	def wait(self):
		# Wait for the process to exit
		self._process.wait()

		# Get the return code
		self._return_code = self._process.returncode

		# Get the standard out and error text
		self._stderr  = self._process.stderr.read().rstrip()
		self._stdout = self._process.stdout.read().rstrip()
		try:
			self._stderr = str(self._stderr, 'UTF-8')
		except Exception as err:
			pass
		try:
			self._stdout = str(self._stdout, 'UTF-8')
		except Exception as err:
			pass

		# :( Failure
		if self._return_code:
			self._status = emoticons.FROWN
		else:
			# :\ Warning
			if len(self._stderr):
				self._status = emoticons.NORMAL
			# :) Success
			else:
				self._status = emoticons.SMILE

	def get_is_done(self):
		# You have to poll a process to update the retval. Even if it has stopped already
		if self._process.returncode == None:
			self._process.poll()
		return self._process.returncode != None
	is_done = property(get_is_done)

	def get_is_success(self):
		self._require_wait()
		return self._status == emoticons.SMILE
	is_success = property(get_is_success)

	def get_is_warning(self):
		self._require_wait()
		return self._status == emoticons.NORMAL
	is_warning = property(get_is_warning)

	def get_is_failure(self):
		self._require_wait()
		return self._status == emoticons.FROWN
	is_failure = property(get_is_failure)

	def get_stderr(self):
		self._require_wait()
		return self._stderr
	stderr = property(get_stderr)

	def get_stdout(self):
		self._require_wait()
		return self._stdout
	stdout = property(get_stdout)

	def get_stdall(self):
		self._require_wait()
		return self._stdout + '\n' + self._stderr
	stdall = property(get_stdall)

	def _require_wait(self):
		if self._return_code == None:
			raise Exception("Wait needs to be called before any info on the process can be gotten.")


class Event(object):
	is_parallel = False
	is_first_parallel = False
	events = []

	def __init__(self, task, result, plural, singular, command, setup_cb):
		self._status = 'ready'
		self._runner = None

		self._task = task
		self._result = result
		self._plural = plural
		self._singular = singular
		self._command = command
		self._setup_cb = setup_cb

	def get_is_done(self):
		return self._runner.is_done
	is_done = property(get_is_done)

	def run(self):
		global message_length

		# Show the parallel header
		if Event.is_parallel:
			if Event.is_first_parallel:
				Event.is_first_parallel = False
				sys.stdout.write("{0} {1} in parallel ...\n".format(self._task, self._plural))
				sys.stdout.flush()
				message_length = 0

		# Run the setup function
		if not self._setup_cb():
			return False

		# Show the serial message
		if not Event.is_parallel:
			print_status("{0} {1} '{2}'".format(self._task, self._singular, self._result))

		# Start the process
		self._runner = ProcessRunner(self._command)
		self._status = 'running'
		self._runner.run()
		return True

	def wait(self):
		# Wait for the process to complete
		self._runner.wait()

		# Display the message
		if Event.is_parallel:
			print_status("   '{0}'".format(self._result))

		# Success or failure
		if self._runner.is_success:
			print_ok()
			self._status = 'success'
		elif self._runner.is_warning:
			print_warning(self._runner.stderr)
			self._status = 'success'
		else:
			print_fail(self._runner.stdall)
			print_exit("{0} failed. Try again.".format(self._task))
			self._status = 'failure'

def add_event(event):
	Event.events.append(event)

	# If not parallel, run the event now
	if not Event.is_parallel:
		parallel_end()

def parallel_start():
	Event.is_parallel = True
	Event.is_first_parallel = True

def parallel_end():
	ready_events = Event.events
	running_events = []

	while len(ready_events) or len(running_events):
		# Check for events that are done
		for event in running_events[:]:
			# Check if it is done
			if event.is_done:
				event.wait()

			# Success. Keep going
			if event._status == 'success':
				running_events.remove(event)
				config._cpus_free += 1
			# Failure. Stop events and exit
			elif event._status == 'failure':
				print_exit("Event failed.")

		# Check for events that need to start
		while config._cpus_free > 0 and len(ready_events):
			event = ready_events.pop()
			if event.run():
				config._cpus_free -= 1
				running_events.insert(0, event)

		# Sleep if all the cpu cores are busy, or have already started
		if config._cpus_free == 0 or len(ready_events) == 0:
			time.sleep(0.1)

	# Clear all the events
	config._cpus_free = config._cpus_total
	Event.events = []
	Event.is_parallel = False
	Event.is_first_parallel = False

def SelfDeletingNamedTemporaryFile():
	f = tempfile.NamedTemporaryFile(delete=False)
	f.close()

	def cb():
		if os.path.exists(f.name):
			os.unlink(f.name)

	atexit.register(cb)

	return f

def require_root():
	is_root = False

	# Cygwin
	if config._os_type._name == 'Cygwin':
		# Cygwin has no root user
		is_root = True
	# Windows
	elif config._os_type._name == 'Windows':
		try:
			# Only Admin can read the C:\windows\temp
			sys_root = os.environ.get('SystemRoot','C:\windows')
			temp = os.listdir(os.path.join(sys_root, 'temp'))
			is_root = True
		except:
			pass
	# Linux / Unix
	elif os.getuid() == 0:
		is_root = True

	# Make sure we are root
	if not is_root:
		print_exit("Must be run as root.")

def require_not_root():
	# On Windows/Cygwin it does not matter if we are root. So just return
	if config._os_type._name in ['Windows', 'Cygwin']:
		return
	
	# Make sure we are NOT root
	if os.getuid() == 0:
		print_exit("Must not be run as root.")

def call_on_exit(cb):
	# Set a cleanup function to run on exit
	if cb:
		atexit.register(cb)

# FIXME: Rename to run_print
def run_say(command):
	print_status("Running command")

	runner = ProcessRunner(command)
	runner.run()
	runner.wait()

	if runner.is_success or runner.is_warning:
		print_ok()
		print(command)
		print(runner.stdall)
	elif runner.is_failure:
		print_fail()
		print(command)
		print(runner.stdall)
		print_exit('Failed to run command.')

def is_outdated(to_update, triggers):
	# Exit if any triggers don't exist
	for trigger in triggers:
		if not os.path.isfile(os.path.abspath(trigger)):
			print_fail()
			print_exit("The file '{0}' does not exist.".format(trigger))

	# Return true if any of the files to check do not exist
	for update in to_update:
		if not os.path.isfile(os.path.abspath(update)):
			return True

	# Get the modify date of the newest trigger file and file to check
	s, b = 0, 0
	for trigger in triggers:
		t = os.path.getmtime(trigger)
		if t > s:
			s = t
	for update in to_update:
		t = os.path.getmtime(update)
		if t > b:
			b = t

	# Rebuild if a trigger is newer than the newest file to check
	if s > b:
		return True
	else:
		return False

def _do_on_fail_exit(start_message, fail_message, cb):
	print_status(start_message)

	# Run it if it is a function
	if hasattr(cb, '__call__'):
		try:
			cb()
			print_ok()
		except Exception as e:
			print_fail()
			print_exit(fail_message)
	# Or run it as a process if a string
	elif type(cb) == str:
		runner = ProcessRunner(cb)
		runner.run()
		runner.wait()
		if runner.is_success or runner.is_warning:
			print_ok()
		elif runner.is_failure:
			print_fail()
			print_exit(fail_message)

def _do_on_fail_pass(start_message, cb):
	print_status(start_message)
	try:
		cb()
	except Exception as e:
		pass
	print_ok()

def cd(name):
	_do_on_fail_exit("Changing to dir '{0}'".format(name),
					"Failed to change to the dir '{0}'.".format(name),
				lambda: os.chdir(name))

def mvfile(source, dest):
	source = to_native(source)
	dest = to_native(dest)

	_do_on_fail_exit("Moving the file '{0}' to '{1}'".format(source, dest),
					"Failed to move the file' {0}'.".format(source),
				lambda: shutil.move(source, dest))

def cpfile(source, dest):
	source = to_native(source)
	dest = to_native(dest)
	_do_on_fail_exit("Copying the file '{0}' to '{1}'".format(source, dest),
					"Failed to copy the file '{0}' to '{1}'.".format(source, dest),
				lambda: shutil.copy2(source, dest))

def cp_new_file(source, dest):
	source = to_native(source)
	dest = to_native(dest)

	if not os.path.isfile(os.path.abspath(dest)):
		cpfile(source, dest)
	elif not filecmp.cmp(source, dest):
		cpfile(source, dest)

def cpdir(source, dest, symlinks = False):
	_do_on_fail_exit("Copying the dir '{0}' to '{1}'".format(source, dest),
					"Failed to copy the dir '{0}' to '{1}'.".format(source, dest),
				lambda: shutil.copytree(source, dest, symlinks = symlinks))

def mkdir_f(source):
	_do_on_fail_pass("Making the dir '{0}'".format(source),
				lambda: os.mkdir(source))

def mkdir(source):
	_do_on_fail_exit("Making the dir '{0}'".format(source),
					"Failed to make the dir '{0}'.".format(source),
				lambda: os.mkdir(source))

def rmdir_and_children(name):
	print_status("Removing the dir '{0}'".format(name))

	# Make sure we are not removing the current directory
	if name == os.getcwd():
		print_fail()
		print_exit("Can't remove the current directory '{0}'.".format(name))

	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isdir(name):
			shutil.rmtree(name)
		print_ok()
	except OSError as e:
		if 'No such file or directory' in e:
			print_ok()
			return
		print_fail()
		print_exit("Failed to remove the dir '{0}'.".format(name))

def rmdir(name):
	print_status("Removing the dir '{0}'".format(name))

	# Make sure we are not removing the current directory
	if name == os.getcwd():
		print_fail()
		print_exit("Can't remove the current directory '{0}'.".format(name))

	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isdir(name):
			os.rmdir(name)
	except OSError as e:
		if 'Directory not empty' in e:
			pass
		elif 'No such file or directory' in e:
			pass
		else:
			print_fail()
			print_exit("Failed to remove the dir '{0}'.".format(name))

	print_ok()

def rmfile(name):
	name = to_native(name)

	print_status("Removing the file '{0}'".format(name))
	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isfile(name):
			os.remove(name)
		print_ok()
	except Exception as e:
		print_fail()
		print_exit("Failed to remove the file '{0}'.".format(name))

def rmfile_f(name):
	name = to_native(name)

	print_status("Removing the file '{0}'".format(name))
	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isfile(name):
			os.remove(name)
	except Exception as e:
		pass

	print_ok()

def symlink(source, link_name):
	source = to_native(source)
	link_name = to_native(link_name)

	_do_on_fail_exit("Symlinking '{0}' to '{1}'".format(source, link_name),
					"Failed linking '{0}' to '{1}'.".format(source, link_name),
				lambda: os.symlink(source, link_name))

def ldconfig():
	# Setup the message
	print_status("Running 'ldconfig'")

	# Skip ldconfig on Cygwin
	if config._os_type._name == 'Cygwin':
		print_ok()
		return

	# Run the process
	runner = ProcessRunner("ldconfig")
	runner.run()
	runner.wait()

	# Success or failure
	if runner.is_failure:
		print_fail(runner.stdall)
		print_exit("Failed run 'ldconfig'.")
	elif runner.is_success or runner.is_warning:
		print_ok()

# Returns all the paths that libraries are installed in
def _get_library_paths():
	paths = ['/usr/lib']
	if not os.path.exists('/etc/ld.so.conf.d/'):
		return paths

	for file_name in os.listdir('/etc/ld.so.conf.d/'):
		f = open('/etc/ld.so.conf.d/' + file_name, 'r')
		for path in f.readlines():
			path = path.strip()
			if os.path.exists(path) and not path in paths:
				paths.append(path)

	return paths

# Returns the full path of a library file or None
def _get_library_path(lib_name, extension):
	lib_name += extension
	for path in _get_library_paths():
		for dirs, subdirs, files in os.walk(path):
			for f in files:
				file_name = lib_name.split('/')[-1]
				path_end = lib_name[0:-(len(file_name)+1)]
				if dirs.endswith(path_end) and f == file_name:
					return os.path.join(dirs, file_name)

	return None

# Returns true if a library is installed
def _is_library_installed(lib_name, extension):
	if _get_library_path(lib_name, extension):
		return True
	else:
		return False

# Returns the full path of a library file or throws and exception
def _library_path(lib_name, extension):
	path = _get_library_path(lib_name, extension)
	if path:
		return path
	else:
		raise Exception("Library '{0}' not found.".format(lib_name))

def require_static_library(lib_name):
	print_status("Checking for static library '{0}'".format(lib_name))

	# Check if the library is installed
	is_installed = _is_library_installed(lib_name, '.a')

	# If not, make them install the lib to continue
	if not is_installed:
		print_fail()
		print_exit("Static library '{0}' not installed. Install and try again.".format(lib_name))
	else:
		print_ok()

def require_shared_library(lib_name):
	print_status("Checking for shared library '{0}'".format(lib_name))
	is_installed = _is_library_installed(lib_name, '.so')

	# Make them install the lib to continue
	if not is_installed:
		print_fail()
		print_exit("Shared library '{0}' not installed. Install and try again.".format(lib_name))

	# Make them run ldconfig if the library is not found by ld
	f = SelfDeletingNamedTemporaryFile()
	runner = ProcessRunner("ld -l " + lib_name.lstrip('lib') + ' -o ' + f.name)
	runner.run()
	runner.wait()
	if runner.is_success or runner.is_warning:
		print_ok()
	elif runner.is_failure:
		print_fail()
		print_exit("Shared library '{0}' not found with 'ld'. Run 'sudo ldconfig' and try again.".format(lib_name))

def require_static_or_shared_library(lib_name):
	print_status("Checking for static/shared library '{0}'".format(lib_name))
	is_static_installed = _is_library_installed(lib_name, '.a')
	is_shared_installed = _is_library_installed(lib_name, '.so')

	# Make them install the lib if neither was found
	if not is_static_installed and not is_shared_installed:
		print_fail()
		print_exit("Static/Shared library '{0}' not installed. Install and try again.".format(lib_name))

	# Success if the static library is installed
	if is_static_installed:
		print_ok()
		return

	# Success if the shared library is installed and found by ldconfig
	if is_shared_installed:
		f = SelfDeletingNamedTemporaryFile()
		runner = ProcessRunner("ld -l " + lib_name.lstrip('lib') + ' -o ' + f.name)
		runner.run()
		runner.wait()
		if runner.is_success or runner.is_warning:
			print_ok()
		elif runner.is_failure:
			print_fail()
			print_exit("Shared library '{0}' not found with 'ld'. Run 'sudo ldconfig' and try again.".format(lib_name))

def require_static_libraries(lib_names):
	for lib_name in lib_names:
		require_static_library(lib_name)

def require_shared_libraries(lib_names):
	for lib_name in lib_names:
		require_shared_library(lib_name)

def require_static_or_shared_libraries(lib_names):
	for lib_name in lib_names:
		require_static_or_shared_library(lib_name)

def require_raise_dependencies():
	# Get a list of all the programs raise uses
	prog_names = None
	if config._os_type._name == 'Windows':
		prog_names = ['cl.exe', 'link.exe']
	else:
		prog_names = ['gcc', 'ar', 'ld']

	# See which programs are not installed
	fails = []
	for prog_name in prog_names:
		names = program_paths(prog_name)
		if len(names) == 0:
			fails.append(prog_name)

	# Print them in a list then exit
	if fails:
		print_info("Raise is checking for its dependencies")
		for f in fails:
			print_status("Checking for program '{0}'".format(f))
			print_fail()
		print_exit("Install the dependencies '{0}' and try again.".format(str.join("', '", fails)))

def require_programs(prog_names):
	for prog_name in prog_names:
		print_status("Checking for program '{0}'".format(prog_name))
		if len(program_paths(prog_name)):
			print_ok()
		else:
			print_fail()
			print_exit("Install the program '{0}' and try again.".format(prog_name))

def require_python_modules(mod_names):
	for mod_name in mod_names:
		_do_on_fail_exit(
			"Checking for python module '{0}'".format(mod_name),
			"Install the python module '{0}' and try again.".format(mod_name),
			'{0} -c "import {1}"'.format(python, mod_name)
		)

def program_paths(program_name):
	paths = []
	exts = filter(None, os.environ.get('PATHEXT', '').split(os.pathsep))
	path = os.environ['PATH']
	for p in os.environ['PATH'].split(os.pathsep):
		p = os.path.join(p, program_name)
		if os.access(p, os.X_OK):
			paths.append(p)
		for e in exts:
			pext = p + e
			if os.access(pext, os.X_OK):
				paths.append(pext)
	return paths

def header_path(header_name):
	retval = None

	# Get any paths that contain the library name
	paths = []
	include_paths = [
		"/usr/include", 
		"/usr/local/include"
	]
	for include_path in include_paths:
		for root, dirs, files in os.walk(include_path):
			for file_name in files:
				complete_name = os.path.join(root, file_name)
				if complete_name.endswith(header_name):
					paths.append(complete_name)

	# Of those paths, get the ones that match the architecture
	for path in paths:
		if 'lib' + config._bits in path or config._arch in path:
			retval = path

	# If none were matched specifically from the architecture
	# Use the first
	if retval == None and paths:
		retval = paths[0]

	# Make sure a header file was found
	if not retval or not os.path.exists(retval):
		raise Exception("Header file not found: '" + header_name + "'")

	i = retval.rfind('/') + 1
	return retval[:i]

def header_paths(header_names):
	paths = []
	for header_name in header_names:
		paths.append(header_path(header_name))

	return paths

def include_path(header_name):
	return '-I' + header_path(header_name)

def include_paths(header_names):
	paths = []
	for header_name in header_names:
		paths.append(include_path(header_name))
	return str.join(' ', paths)

def shared_library_path(lib_name):
	return _library_path(lib_name, '.so')

def static_library_path(lib_name):
	return _library_path(lib_name, '.a')

def static_or_shared_library_path(lib_name):
	try:
		return static_library_path(lib_name)
	except Exception as e:
		pass

	try:
		return shared_library_path(lib_name)
	except Exception as e:
		pass

	raise Exception("Static/Shared library not found: '" + lib_name + "'")

def link_shared_path(lib_name):
	return '-L' + shared_library_path(lib_name)

def link_static_path(lib_name):
	return '-L' + static_library_path(lib_name)

def link_static_or_shared_path(lib_name):
	return '-L' + static_or_shared_library_path(lib_name)

def link_shared_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_shared_path(lib_name))
	return str.join(' ', paths)

def link_static_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_static_path(lib_name))
	return str.join(' ', paths)

def link_static_or_shared_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_static_or_shared_path(lib_name))
	return str.join(' ', paths)


# Other C compilers: Clang, DMC, Dingus, Elsa, PCC
# http://en.wikipedia.org/wiki/List_of_compilers#C_compilers
class Compiler(object):
	def __init__(self, name, path, default_flags, out_file, no_link, 
				debug, warnings_all, warnings_as_errors):

		self._name = name
		self._path = path

		# Save text for all the options
		self._opt_default_flags = default_flags
		self._opt_out_file = out_file
		self._opt_no_link = no_link
		self._opt_debug = debug
		self._opt_warnings_all = warnings_all
		self._opt_warnings_as_errors = warnings_as_errors

		# Set the default values of the flags
		self.debug = False
		self.warnings_all = False
		self.warnings_as_errors = False

class Linker(object):
	def __init__(self, name, default_flags, out_file, shared):
		self._name = name
		
		self._opt_default_flags = default_flags
		self._opt_out_file = out_file
		self._opt_shared = shared

def to_native(thing):
	# Get a dict of the standard extensions and their other os counterparts
	replaces = {
		'.o' : config._os_type._object_extension,
		'.so': config._os_type._shared_lib_extension,
		'.a' : config._os_type._static_lib_extension
	}

	# Replace the extension
	if type(thing) == list:
		for before, after in replaces.items():
			thing = [o.replace(before, after) for o in thing]
	else:
		for before, after in replaces.items():
			thing = thing.replace(before, after)

	return thing

def require_module(name):
	global modules

	modules.append(name)

def _c_module_setup():
	global c_compilers
	global c_linkers

	# Get the names and paths for know C compilers
	names = ['gcc', 'clang', 'cl.exe']
	for name in names:
		paths = program_paths(name)
		if len(paths) == 0:
			continue

		if name == 'gcc':
			comp = Compiler(
				name =                 'gcc', 
				path =                 paths[0], 
				default_flags =        '', 
				out_file =             '-o ', 
				no_link =              '-c', 
				debug =                '-g', 
				warnings_all =         '-Wall', 
				warnings_as_errors =   '-Werror'
			)
			c_compilers[comp._name] = comp
		elif name == 'clang':
			comp = Compiler(
				name =                 'clang', 
				path =                 paths[0], 
				default_flags =        '', 
				out_file =             '-o ', 
				no_link =              '-c', 
				debug =                '-g', 
				warnings_all =         '-Wall', 
				warnings_as_errors =   '-Werror'
			)
			c_compilers[comp._name] = comp
		elif name == 'cl.exe':
			# http://msdn.microsoft.com/en-us/library/19z1t1wy.aspx
			comp = Compiler(
				name =                 'cl.exe', 
				path =                 paths[0], 
				default_flags =        '/nologo', 
				out_file =             '/Fe', 
				no_link =              '/c', 
				debug =                '', 
				warnings_all =         '/Wall', 
				warnings_as_errors =   ''
			)
			c_compilers[comp._name] = comp

	# Make sure there is at least one C compiler installed
	if len(c_compilers) == 0:
		print_status("Setting up C module")
		print_fail()
		print_exit("No C compiler found. Install one and try again.")

	# Get the names and paths for know linkers
	names = ['ld', 'link.exe']
	for name in names:
		paths = program_paths(name)
		if len(paths) == 0:
			continue

		if name == 'link.exe':
			link = Linker(
				name            = 'link.exe',
				default_flags   = '/nologo', 
				out_file        = '/out:', 
				shared          = '/dll '
			)
			c_linkers[link._name] = link
		elif name == 'ld':
			link = Linker(
				name            = 'ld',
				default_flags   = '', 
				out_file        = '-o ', 
				shared          = '-G'
			)
			c_linkers[link._name] = link

	# Make sure there is at least one linker installed
	if len(c_linkers) == 0:
		print_status("Setting up C module")
		print_fail()
		print_exit("No linker found. Install one and try again.")

def _c_require_module():
	# Just return if setup
	if c_compilers:
		return

	print_status("C module check")
	print_fail()
	print_exit("Call require_module('C') before using any C functions.")

def c_get_default_linker():
	global c_linkers
	_c_require_module()

	if config._os_type._name == 'Windows':
		return c_linkers['link.exe']
	else:
		return c_linkers['ld']

def c_save_linker(linker):
	_c_require_module()

	# CLINKER
	global config
	config._clinker = linker
	os.environ['CLINKER'] = config._clinker._name

def c_get_default_compiler():
	global c_compilers
	_c_require_module()

	comp = None

	if config._os_type._name == 'Windows':
		comp = c_compilers['cl.exe']
	else:
		if 'gcc' in c_compilers:
			comp = c_compilers['gcc']
		elif 'clang' in c_compilers:
			comp = c_compilers['clang']

	return comp

def c_save_compiler(compiler):
	_c_require_module()

	# CC
	global config
	config._cc = compiler
	os.environ['CC'] = config._cc._name

	# CFLAGS
	opts = []
	opts.append(config._cc._opt_default_flags)
	if config._cc.debug: opts.append(config._cc._opt_debug)
	if config._cc.warnings_all: opts.append(config._cc._opt_warnings_all)
	if config._cc.warnings_as_errors: opts.append(config._cc._opt_warnings_as_errors)
	os.environ['CFLAGS'] = str.join(' ', opts)

def c_build_object(o_file, c_files, i_files=[]):
	_c_require_module()

	# Change file extensions to os format
	o_file = to_native(o_file)
	c_files = to_native(c_files)
	i_files = to_native(i_files)

	# Setup the messages
	task = 'Building'
	result = o_file
	plural = 'C objects'
	singular = 'C object'
	command = "${CC} ${CFLAGS} " + \
				config._cc._opt_no_link + ' ' +  \
				config._cc._opt_out_file + \
				o_file + ' ' + \
				str.join(' ', c_files) + ' ' + \
				str.join(' ', i_files)

	def setup():
		# Skip if the files have not changed since last build
		if not is_outdated(to_update = [o_file], triggers = c_files):
			return False

		# Make sure the environmental variable is set
		if not 'CC' in os.environ:
			print_fail()
			print_exit("Set the env variable 'CC' to the C compiler, and try again.")

		return True

	# Create the event
	event = Event(task, result, plural, singular, command, setup)
	add_event(event)

def c_build_program(o_file, c_files, i_files=[]):
	_c_require_module()

	# Change file extensions to os format
	o_file = to_native(o_file)
	c_files = to_native(c_files)
	i_files = to_native(i_files)

	# Setup the messages
	task = 'Building'
	result = o_file
	plural = 'C programs'
	singular = 'C program'
	command = '${CC} ${CFLAGS} ' + \
				str.join(' ', c_files) + ' ' + \
				str.join(' ', i_files) + ' ' + \
				config._cc._opt_out_file + o_file

	def setup():
		# Make sure the environmental variable is set
		if not 'CC' in os.environ:
			print_fail()
			print_exit("Set the env variable 'CC' to the C compiler, and try again.")

		return True

	# Create the event
	event = Event(task, result, plural, singular, command, setup)
	add_event(event)


# FIXME: Rename to c_build_static_library
def ar_build_static_library(ar_file, o_files):
	_c_require_module()

	# Change file extensions to os format
	ar_file = to_native(ar_file)
	o_files = to_native(o_files)

	# Setup the messages
	task = 'Building'
	result = ar_file
	plural = 'static libraries'
	singular = 'static library'
	command = "ar rcs " + \
			ar_file + " " + \
			str.join(' ', o_files)

	def setup():
		# Skip if the files have not changed since last build
		if not is_outdated(to_update = [ar_file], triggers = o_files):
			return False
		return True

	# Create the event
	event = Event(task, result, plural, singular, command, setup)
	add_event(event)

def c_build_shared_library(so_file, o_files):
	_c_require_module()

	# Change file extensions to os format
	so_file = to_native(so_file)
	o_files = to_native(o_files)

	# Setup the messages
	task = 'Building'
	result = so_file
	plural = 'shared libraries'
	singular = 'shared library'
	command = "{0} {1} {2} {3} {4}{5}".format(
				config._clinker._name, 
				config._clinker._opt_default_flags, 
				config._clinker._opt_shared, 
				str.join(' ', o_files), 
				config._clinker._opt_out_file, 
				so_file)

	def setup():
		# Skip if the files have not changed since last build
		if not is_outdated(to_update = [so_file], triggers = o_files):
			return False
		return True

	# Create the event
	event = Event(task, result, plural, singular, command, setup)
	add_event(event)

def _d_module_setup():
	global d_compilers

	# Get the names and paths for know D compilers
	names = ['dmd', 'ldc2']
	for name in names:
		paths = program_paths(name)
		if len(paths) == 0:
			continue

		if name == 'dmd':
			comp = Compiler(
				name =                 'dmd', 
				path =                  paths[0], 
				default_flags =        '', 
				out_file =             '-of', 
				no_link =              '-c', 
				debug =                '-g', 
				warnings_all =         '-w', 
				warnings_as_errors =   ''
			)
			d_compilers[comp._name] = comp
		elif name == 'ldc2':
			comp = Compiler(
				name =                 'ldc2', 
				path =                  paths[0], 
				default_flags =        '', 
				out_file =             '-of', 
				no_link =              '-c', 
				debug =                '-g', 
				warnings_all =         '-w', 
				warnings_as_errors =   ''
			)
			d_compilers[comp._name] = comp

	# Make sure there is at least one D compiler installed
	if len(d_compilers) == 0:
		print_status("Setting up D module")
		print_fail()
		print_exit("No D compiler found. Install one and try again.")

def _d_require_module():
	# Just return if setup
	if d_compilers:
		return

	print_status("D module check")
	print_fail()
	print_exit("Call require_module('D') before using any D functions.")

def d_get_default_compiler():
	global d_compilers
	_d_require_module()

	comp = None
	if 'dmd' in d_compilers:
		comp = d_compilers['dmd']
	elif 'ldc2' in d_compilers:
		comp = d_compilers['ldc2']

	return comp

def d_save_compiler(compiler):
	_d_require_module()

	# DC
	global config
	config._dc = compiler
	os.environ['DC'] = config._dc._name

	# DFLAGS
	opts = []
	if config._dc.debug: opts.append(config._dc._opt_debug)
	if config._dc.warnings_all: opts.append(config._dc._opt_warnings_all)
	if config._dc.warnings_as_errors: opts.append(config._dc._opt_warnings_as_errors)
	os.environ['DFLAGS'] = str.join(' ', opts)

def d_build_interface(d_file, i_files):
	_d_require_module()

	d_file = to_native(d_file)
	i_files = to_native(i_files)

	# Setup the messages
	task = 'Building'
	result = d_file + 'i'
	plural = 'D interfaces'
	singular = 'D interface'

	f = SelfDeletingNamedTemporaryFile()
	command = "${DC} ${DFLAGS} -c " + d_file + " " + str.join(' ', i_files) + " -Hf" + d_file + "i " + config._dc._opt_out_file + f.name

	def setup():
		if not is_outdated(to_update = [d_file+'i'], triggers = [d_file]):
			return False

		if not 'DC' in os.environ:
			print_fail()
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		return True

	# Create the event
	event = Event(task, result, plural, singular, command, setup)
	add_event(event)

def d_build_object(o_file, d_files, i_files, l_files=[], h_files=[]):
	_d_require_module()

	o_file = to_native(o_file)
	d_files = to_native(d_files)
	i_files = to_native(i_files)
	l_files = to_native(l_files)
	h_files = to_native(h_files)

	# Setup the messages
	task = 'Building'
	result = o_file
	plural = 'D objects'
	singular = 'D object'

	command = "${DC} ${DFLAGS} -c " + config._dc._opt_out_file + o_file + " " + str.join(' ', d_files) + " " + str.join(' ', i_files) + " " + str.join(' ', l_files)
	if h_files:
		command += " -H -Hdimport -Hf" + str.join(' ', h_files)

	def setup():
		if not is_outdated(to_update = [o_file], triggers = d_files):
			return False

		if not 'DC' in os.environ:
			print_fail()
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		return True

	# Create the event
	event = Event(task, result, plural, singular, command, setup)
	add_event(event)

def d_build_shared_library(o_file, d_files, i_files, l_files=[], generate_headers=False):
	_d_require_module()

	o_file = to_native(o_file)
	d_files = to_native(d_files)
	i_files = to_native(i_files)
	l_files = to_native(l_files)

	# Setup the messages
	task = 'Building'
	result = o_file
	plural = 'D shared libraries'
	singular = 'D shared library'

	command = "${DC} ${DFLAGS} -shared " + config._dc._opt_out_file + o_file + " " + str.join(' ', d_files) + " " + str.join(' ', i_files) + " " + str.join(' ', l_files)
	if generate_headers:
		command += "  -Hdimport -H"

	def setup():
		if not is_outdated(to_update = [o_file], triggers = d_files):
			return False

		if not 'DC' in os.environ:
			print_fail()
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		return True

	# Create the event
	event = Event(task, result, plural, singular, command, setup)
	add_event(event)

def d_build_static_library(o_file, d_files, i_files, l_files, generate_headers=False):
	_d_require_module()

	o_files = to_native(o_files)
	d_files = to_native(d_files)
	i_files = to_native(i_files)
	l_files = to_native(l_files)

	# Setup the messages
	task = 'Building'
	result = o_file
	plural = 'D static libraries'
	singular = 'D static library'

	command = "${DC} ${DFLAGS} -lib " + config._dc._opt_out_file + o_file + " " + str.join(' ', d_files) + " " + str.join(' ', i_files) + " " + str.join(' ', l_files)
	if generate_headers:
		command += "  -Hdimport -H"

	def setup():
		if not 'DC' in os.environ:
			print_fail()
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		return True

	# Create the event
	event = Event(task, result, plural, singular, command, setup)
	add_event(event)

def d_build_program(out_file, inc_files, link_files=[]):
	_d_require_module()

	out_file = to_native(out_file)
	inc_files = to_native(inc_files)
	link_files = to_native(link_files)

	# Setup the messages
	task = 'Building'
	result = out_file
	plural = 'D programs'
	singular = 'D program'
	command = "${DC} ${DFLAGS} " + config._dc._opt_out_file + out_file + ' ' + str.join(' ', inc_files) + " " + str.join(' ', link_files)

	def setup():
		if not 'DC' in os.environ:
			print_fail()
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		return True

	# Create the event
	event = Event(task, result, plural, singular, command, setup)
	add_event(event)

def load_rscript(g=globals(), l=locals()):
	# Make sure there is an rscript file
	if not os.path.isfile('rscript'):
		return None

	# Get a list of all the functions
	before = []
	for key in globals().keys():
		before.append(key)

	# Load the rscript file into this namespace
	with open('rscript', 'rb') as f:
		code = None
		try:
			code = compile(f.read(), 'rscript', 'exec')
		except Exception as e:
			print_exit(e)

		exec(code, g, l)

	# Get just the target functions
	targets = {}
	for key in globals().keys():
		if not key in before:
			if not key.startswith('_') and hasattr(globals()[key], '__call__'):
				targets[key] = globals()[key]

	return targets

if __name__ == '__main__':
	# Figure out everything we need to know about the system
	config = Config()

	# Have all KeyboardInterrupt exceptions quit with a clean message
	def signal_handler(signal, frame):
		print_exit('Exit called by the keyboard.')
		exit()
	signal.signal(signal.SIGINT, signal_handler)

	# Clear the terminal
	os.system(config._terminal_clear)

	# Load the rscript
	targets = load_rscript()

	# Get the target function name
	target_name = str(str.join(' ', sys.argv[1:]))

	# Get a friendly list of all the targets
	target_list = []
	if targets:
		keys = list(targets.keys())
		keys.sort()
		target_list = "'" + str.join("', '", keys) + "'"

	# Exit if there is no target
	if not target_name:
		print("Raise software build tool (Version 0.2 - September 13 2013) http://launchpad.net/raise")
		print("")
		print("COMMANDS:")
		print("    ./raise update - Downloads the newest version of Raise. It will be stored in a file named \".raise_actual\" or \"raise_actual\".")
		print("")

		# Print all the targets
		if targets:
			no_doc = "No docstring is provided for this target."
			print("TARGETS:")
			for t in targets:
				doc = targets[t].__doc__ or no_doc
				print("    ./raise {0} - {1}".format(t, doc))
				print("")
			print_exit("No target specified. Found targets are {0}.".format(target_list))
	
	if not targets:
		print_exit("No 'rscript' file found.")

	# Exit if there is no target with that name
	if not target_name in targets:
		print_exit("No target named '{0}'. Found targets are {1}.".format(target_name, target_list))

	# Make sure all the programs we need are installed
	# FIXME: Requiring gcc, ar, ld, and ldconfig makes raise
	# gcc specific. What other linkers and archivers are used
	# with other C compilers? Clang, MS cl, et cetera
	require_raise_dependencies()

	# Setup any modules
	for module in modules:
		if module == 'C':
			_c_module_setup()
		elif module == 'D':
			_d_module_setup()
		else:
			print_exit('Unknown module "{0}"'.format(module))

	# Try running the target
	target = targets[target_name]
	print_info("Running target '{0}'".format(target_name))
	target()


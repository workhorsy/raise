#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# This file is part of Raise.
# Raise is a small software build tool that ships with your code.
# Raise uses a MIT style license, and is hosted at http://launchpad.net/raise .
# Copyright (c) 2013, Matthew Brennan Jones <mattjones@workhorsy.org>
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
# 
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import os, sys, stat
import tempfile
import time
import filecmp
import signal
import platform, re, glob
import shutil
import atexit
import threading
import multiprocessing
import subprocess
import traceback
if sys.version_info < (3, 0):
	import urllib2
	globals()['urlopen'] = urllib2.urlopen
else:
	import urllib.request
	globals()['urlopen'] = urllib.request.urlopen


global pwd
global python
global bits
global arch
global target_name
global terminal_clear
global terminal_width
global message_length
global is_parallel
global parallel_message

def early_exit(message):
	sys.stdout.write(message + ' Exiting ...\n')
	sys.stdout.flush()
	exit()

target_name = None
g_events = []
cpus_total = multiprocessing.cpu_count()
cpus_free = cpus_total
is_parallel = False
parallel_message = None

# Get the path of the rscript file
pwd = os.sys.path[0]


# Make sure we are in at least python 2.6
if sys.version_info < (2, 6):
	early_exit("Python 2.6 or greater is required.")

# Get the name of the current running python program
python = sys.executable
if not python:
	early_exit('Could not find python to run child processes with.')

# Figure out if the CPU is 32bit or 64bit
bits = None
if platform.architecture()[0] == '64bit':
	bits = '64'
else:
	bits = '32'

# Figure out the CPU architecture
arch = None
if re.match('^i\d86$|^x86$|^x86_32$', platform.machine()):
	arch = 'x86_32'
elif platform.machine() == 'x86_64':
	arch = 'x86_64'
else:
	early_exit("Unknown architecture: " + platform.machine() + " .")


# Figure out how to clear the terminal
if platform.system() == 'Windows':
	terminal_clear = 'cls'
else:
	terminal_clear = 'clear'

# FIXME: Have this look for stty first then try the registry
# Figure out the terminal width
if platform.system() == 'Windows':
	import _winreg
	key = _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, r"Console")
	val = _winreg.QueryValueEx(key, "ScreenBufferSize")
	_winreg.CloseKey(key)
	size = hex(val[0])
	terminal_width = int('0x' + size[-4 : len(size)], 16)
else:
	terminal_width = int(os.popen('stty size', 'r').read().split()[1])

def to_native(command):
	if platform.system() == 'Windows':
		# Remove starting ./
		if command.startswith('./'):
			command = command[2 :]
		# Replace ${BLAH} with %BLAH%
		command = command.replace('${', '%').replace('}', '%')
			
	return command

def get_normal_user_name():
	# Get the name from the environmental variable
	user_name = \
		os.getenv('SUDO_USER') or \
		os.getenv('USER') or \
		os.getenv('LOGNAME')

	# Make sure we got a name
	if not user_name:
		print_exit('Failed to get the normal user name.')

	return user_name

def get_normal_user_id():
	user_name = get_normal_user_name()
	return int(os.popen('id -u {0}'.format(user_name)).read())


def do_as_normal_user(cb):
	prev_id = -1

	# Change the user to the normal user
	if platform.system() != 'Windows':
		prev_id = os.geteuid()
		user_id = get_normal_user_id()
		os.setegid(user_id)
		os.seteuid(user_id)

	# Run the cb as the normal user
	exception = False
	is_exiting = False
	try:
		cb()
	except SystemExit as err:
		# Don't save any exit() exceptions. Just exit
		is_exiting = True
	except Exception as err:
		exception = traceback.format_exc()
	except StandardError as err:
		exception = traceback.format_exc()
	except BaseException as err:
		exception = traceback.format_exc()
	finally:
		# Return the user to normal
		if platform.system() != 'Windows':
			os.setegid(prev_id)
			os.seteuid(prev_id)

	if is_exiting:
		exit()
	if exception:
		print_exit(exception)

class bcolors:
	MESSAGE = '\033[44m\033[37m'
	OK = '\033[42m\033[37m'
	FAIL = '\033[41m\033[37m'
	ENDC = '\033[0m'

def terminal_pad(length, pad_char=' '):
	width = terminal_width

	if length > (width-3):
		i = int(width * (int(length / width) + 1)) - 3
	else:
		i = width - 3
	return ''.ljust(i-length, pad_char)

def print_info(message):
	sys.stdout.write(bcolors.MESSAGE + message + bcolors.ENDC + "\n")
	sys.stdout.flush()

def print_status(message):
	global message_length
	message = '{0} ...'.format(message)
	message_length = len(message)

	sys.stdout.write(message)
	sys.stdout.flush()

def print_ok():
	global message_length
	message = terminal_pad(message_length) + bcolors.OK + ":)" + bcolors.ENDC + "\n"
	message_length = 0

	sys.stdout.write(message)
	sys.stdout.flush()

def print_fail(post_fail_message=None):
	global message_length
	message = terminal_pad(message_length, '.') + bcolors.FAIL + ":(" + bcolors.ENDC + "\n"
	if post_fail_message:
		message += post_fail_message + "\n"
	message_length = 0

	sys.stdout.write(message)
	sys.stdout.flush()

def print_exit(message):
	message = bcolors.FAIL + message + ' Exiting ...' + bcolors.ENDC + '\n'

	sys.stdout.write(message)
	sys.stdout.flush()
	exit()

class ProcessRunner(object):
	def __init__(self, command):
		self._command = command
		self._process = None
		self._return_code = None
		self._stdout = None
		self._stderr = None
		self._status = None

	def run(self):
		self._process = subprocess.Popen(
			self._command, 
			stderr = subprocess.PIPE, 
			stdout = subprocess.PIPE, 
			shell = True, 
			env = os.environ.copy()
		)

	def wait(self):
		# Wait for the process to exit
		self._process.wait()

		# Get the return code
		self._return_code = self._process.returncode

		# Get the standard out and error text
		self._stderr  = self._process.stderr.read().rstrip()
		self._stdout = self._process.stdout.read().rstrip()
		try:
			self._stderr = str(self._stderr, 'UTF-8')
		except Exception as err:
			pass
		try:
			self._stdout = str(self._stdout, 'UTF-8')
		except Exception as err:
			pass

		# :( Failure
		if self._return_code:
			self._status = ':('
		# :) Success
		if not self._return_code:
			self._status = ':)'

	def get_is_done(self):
		# You have to poll a process to update the retval. Even if it has stopped already
		if self._process.returncode == None:
			self._process.poll()
		return self._process.returncode != None
	is_done = property(get_is_done)

	def get_is_ok(self):
		self._require_wait()
		return self._status == ':)'
	is_ok = property(get_is_ok)

	def get_is_failure(self):
		self._require_wait()
		return self._status == ':('
	is_failure = property(get_is_failure)

	def get_stderr(self):
		self._require_wait()
		return self._stderr
	stderr = property(get_stderr)

	def get_stdout(self):
		self._require_wait()
		return self._stdout
	stdout = property(get_stdout)

	def _require_wait(self):
		if self._return_code == None:
			raise Exception("Wait needs to be called before any info on the process can be gotten.")


class Event(object):
	def __init__(self, args, func, message):
		self._args = args
		self._func = func
		self._message = message
		self._status = 'ready'
		self._runner = self._func(*self._args)

	def get_is_done(self):
		return self._runner.is_done
	is_done = property(get_is_done)

	def run(self):
		global is_parallel
		# Display the message if not in parallel
		if not is_parallel:
			print_status(self._message)

		self._status = 'running'
		self._runner.run()

	def wait(self):
		global is_parallel
		# Wait for the process to complete
		self._runner.wait()

		# Display the message if in parallel
		if is_parallel:
			print_status(self._message)

		# Success or failure
		if self._runner.is_ok:
			print_ok()
			self._status = 'success'
		else:
			print_fail(self._runner.stderr)
			print_exit("Build failed. Try again.")
			self._status = 'failure'

def parallel_start():
	global is_parallel
	global parallel_message

	is_parallel = True
	parallel_message = None

def parallel_end():
	global g_events
	global cpus_total
	global cpus_free
	global is_parallel
	global parallel_message

	ready_events = g_events
	running_events = []

	if parallel_message:
		sys.stdout.write(parallel_message)
		sys.stdout.flush()

	while len(ready_events) or len(running_events):
		# Check for events that are done
		for event in running_events[:]:
			# Check if it is done
			if event.is_done:
				event.wait()

			# Success. Keep going
			if event._status == 'success':
				running_events.remove(event)
				cpus_free += 1
			# Failure. Stop events and exit
			elif event._status == 'failure':
				print_exit("Event failed.")

		# Check for events that need to start
		while cpus_free > 0 and len(ready_events):
			event = ready_events.pop()
			cpus_free -= 1
			event.run()
			running_events.insert(0, event)

		# Sleep if all the cpu cores are busy, or have already started
		if cpus_free == 0 or len(ready_events) == 0:
			time.sleep(0.1)

	# Clear all the events
	g_events = []
	is_parallel = False
	parallel_message = None

def require_root():
	is_root = False

	# Windows
	if platform.system() == 'Windows':
		try:
			# Only Admin can read the C:\windows\temp
			sys_root = os.environ.get('SystemRoot','C:\windows')
			temp = os.listdir(os.path.join(sys_root, 'temp'))
			is_root = True
		except:
			pass
	# Linux / Unix
	elif os.getuid() == 0:
		is_root = True

	# Make sure we are root
	if not is_root:
		print_exit("Must be run as root.")

def require_not_root():
	# On Windows it does not matter if we are root. So just return
	if platform.system() == 'Windows':
		return
	
	# Make sure we are NOT root
	if os.getuid() == 0:
		print_exit("Must not be run as root.")

def call_on_exit(cb):
	# Set a cleanup function to run on exit
	if cb:
		atexit.register(cb)

def run_sync(command):
	p = run_async(command)
	p.wait()
	return _run_get_output(p)

def run_async(command):
	command = to_native(command)
	p = subprocess.Popen(command, stderr=subprocess.PIPE, stdout=subprocess.PIPE, shell=True, env=os.environ.copy())
	return p

def _run_get_output(p):
	e = p.stderr.read().rstrip()
	o = p.stdout.read().rstrip()
	try:
		e = str(e, 'UTF-8')
	except Exception as err:
		pass
	try:
		o = str(o, 'UTF-8')
	except Exception as err:
		pass

	if p.returncode:
		if len(e) != 0:
			raise Exception(e)
		else:
			raise Exception(o)

	return o

# FIXME: Rename to run_print
def run_say(command):
	global message_length
	command = to_native(command)
	message = "Running command ..."
	message_length = len(message)
	sys.stdout.write(message)
	sys.stdout.flush()
	p = subprocess.Popen(command, stderr=subprocess.PIPE, stdout=subprocess.PIPE, shell=True, env=os.environ.copy())
	p.wait()
	o = p.stdout.read().rstrip()
	e = p.stderr.read().rstrip()
	try:
		e = str(e, 'UTF-8')
	except Exception as err:
		pass
	try:
		o = str(o, 'UTF-8')
	except Exception as err:
		pass

	if p.returncode:
		print_fail()
		if len(o):
			print(o)
		if len(e):
			print(e)
		print_exit('Failed to run command.')
	else:
		print_ok()
		if len(o):
			print(o)
		if len(e):
			print(e)

def is_outdated(message, to_update, triggers):
	# Make sure all the triggers exist
	for trigger in triggers:
		if not os.path.isfile(os.path.abspath(trigger)):
			if is_parallel and parallel_message:
				sys.stdout.write(parallel_message)
				sys.stdout.flush()

			print_status(message)
			print_fail()
			print_exit("The file '" + trigger + "' does not exist.")

	# Rebuild if any of the files to check do not exist
	for update in to_update:
		if not os.path.isfile(os.path.abspath(update)):
			return True

	# Get the modify date of the newest trigger file and file to check
	s, b = 0, 0
	for trigger in triggers:
		t = os.path.getmtime(trigger)
		if t > s:
			s = t
	for update in to_update:
		t = os.path.getmtime(update)
		if t > b:
			b = t

	# Rebuild if a trigger is newer than the newest file to check
	if s > b:
		return True
	else:
		return False

def _do_on_fail_exit(start_message, fail_message, cb):
	print_status(start_message)
	try:
		cb()
		print_ok()
	except Exception as e:
		print_fail()
		print_exit(fail_message)

def _do_on_fail_pass(start_message, cb):
	print_status(start_message)
	try:
		cb()
	except Exception as e:
		pass
	print_ok()

def cd(name):
	_do_on_fail_exit("Changing to dir '{0}'".format(name),
					"Failed to change to the dir '{0}'.".format(name),
				lambda: os.chdir(name))

def mvfile(source, dest):
	_do_on_fail_exit("Moving the file '{0}' to '{1}'".format(source, dest),
					"Failed to move the file' {0}'.".format(source),
				lambda: shutil.move(source, dest))

def cpfile(source, dest):
	_do_on_fail_exit("Copying the file '{0}' to '{1}'".format(source, dest),
					"Failed to copy the file '{0}' to '{1}'.".format(source, dest),
				lambda: shutil.copy2(source, dest))

def cp_new_file(source, dest):
	if not os.path.isfile(os.path.abspath(dest)):
		cpfile(source, dest)
	elif not filecmp.cmp(source, dest):
		cpfile(source, dest)

def cpdir(source, dest, symlinks = False):
	_do_on_fail_exit("Copying the dir '{0}' to '{1}'".format(source, dest),
					"Failed to copy the dir '{0}' to '{1}'.".format(source, dest),
				lambda: shutil.copytree(source, dest, symlinks = symlinks))

def mkdir_f(source):
	_do_on_fail_pass("Making the dir '{0}'".format(source),
				lambda: os.mkdir(source))

def mkdir(source):
	_do_on_fail_exit("Making the dir '{0}'".format(source),
					"Failed to make the dir '{0}'.".format(source),
				lambda: os.mkdir(source))

def rmdir_and_children(name):
	print_status("Removing the dir '{0}'".format(name))

	# Make sure we are not removing the current directory
	if name == os.getcwd():
		print_fail()
		print_exit("Can't remove the current directory '{0}'.".format(name))

	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isdir(name):
			shutil.rmtree(name)
		print_ok()
	except OSError as e:
		if 'No such file or directory' in e:
			print_ok()
			return
		print_fail()
		print_exit("Failed to remove the dir '{0}'.".format(name))

def rmdir(name):
	print_status("Removing the dir '{0}'".format(name))

	# Make sure we are not removing the current directory
	if name == os.getcwd():
		print_fail()
		print_exit("Can't remove the current directory '{0}'.".format(name))

	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isdir(name):
			os.rmdir(name)
	except OSError as e:
		if 'Directory not empty' in e:
			pass
		elif 'No such file or directory' in e:
			pass
		else:
			print_fail()
			print_exit("Failed to remove the dir '{0}'.".format(name))

	print_ok()

def rmfile(name):
	print_status("Removing the file '{0}'".format(name))
	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isfile(name):
			os.remove(name)
		print_ok()
	except Exception as e:
		print_fail()
		print_exit("Failed to remove the file '{0}'.".format(name))

def rmfile_f(name):
	print_status("Removing the file '{0}'".format(name))
	try:
		if os.path.islink(name):
			os.unlink(name)
		elif os.path.isfile(name):
			os.remove(name)
	except Exception as e:
		pass

	print_ok()

def symlink(source, link_name):
	_do_on_fail_exit("Symlinking '{0}' to '{1}'".format(source, link_name),
					"Failed linking '{0}' to '{1}'.".format(source, link_name),
				lambda: os.symlink(source, link_name))

def ldconfig():
	_do_on_fail_exit("Running 'ldconfig'",
					"Failed run 'ldconfig'.",
				lambda: run_sync('ldconfig'))

def updatedb():
	updatedb_name = None
	# Updatedb on BSD and OSX
	if os.path.exists('/usr/libexec/locate.updatedb'):
		updatedb_name = '/usr/libexec/locate.updatedb'
	# Updatedb on Linux
	else:
		updatedb_name = 'updatedb'

	_do_on_fail_exit("Running 'updatedb'",
					"Failed run 'updatedb'.",
				lambda: run_sync(updatedb_name))

# Returns all the paths that libraries are installed in
def _get_library_paths():
	paths = ['/usr/lib']
	if not os.path.exists('/etc/ld.so.conf.d/'):
		return paths

	for file_name in os.listdir('/etc/ld.so.conf.d/'):
		f = open('/etc/ld.so.conf.d/' + file_name, 'r')
		for path in f.readlines():
			path = path.strip()
			if os.path.exists(path) and not path in paths:
				paths.append(path)

	return paths

# Returns the full path of a library file or None
def _get_library_path(lib_name, extension):
	lib_name += extension
	for path in _get_library_paths():
		for dirs, subdirs, files in os.walk(path):
			for f in files:
				file_name = lib_name.split('/')[-1]
				path_end = lib_name[0:-(len(file_name)+1)]
				if dirs.endswith(path_end) and f == file_name:
					return os.path.join(dirs, file_name)

	return None

# Returns true if a library is installed
def _is_library_installed(lib_name, extension):
	if _get_library_path(lib_name, extension):
		return True
	else:
		return False

# Returns the full path of a library file or throws and exception
def _library_path(lib_name, extension):
	path = _get_library_path(lib_name, extension)
	if path:
		return path
	else:
		raise Exception("Library '{0}' not found.".format(lib_name))

def require_static_library(lib_name):
	print_status("Checking for static library '{0}'".format(lib_name))
	is_installed = _is_library_installed(lib_name, '.a')

	# Make them install the lib to continue
	if not is_installed:
		print_fail()
		print_exit("Static library '{0}' not installed. Install and try again.".format(lib_name))

	# Make them run updatedb if the library is not found by locate
	try:
		run_sync("locate /" + lib_name + ".a")
		print_ok()
	except Exception as e:
		print_fail()
		print_exit("Static library '{0}' not found with 'locate'. Run 'sudo updatedb' and try again.".format(lib_name))

def require_shared_library(lib_name):
	print_status("Checking for shared library '{0}'".format(lib_name))
	is_installed = _is_library_installed(lib_name, '.so')

	# Make them install the lib to continue
	if not is_installed:
		print_fail()
		print_exit("Shared library '{0}' not installed. Install and try again.".format(lib_name))

	# Make them run ldconfig if the library is not found by ld
	f = tempfile.NamedTemporaryFile(delete=False)
	f.close()
	try:
		run_sync("ld -l " + lib_name.lstrip('lib') + ' -o ' + f.name)
		print_ok()
	except Exception as e:
		print_fail()
		print_exit("Shared library '{0}' not found with 'ld'. Run 'sudo ldconfig' and try again.".format(lib_name))
	finally:
		os.unlink(f.name)

def require_static_or_shared_library(lib_name):
	print_status("Checking for static/shared library '{0}'".format(lib_name))
	is_static_installed = _is_library_installed(lib_name, '.a')
	is_shared_installed = _is_library_installed(lib_name, '.so')

	# Make them install the lib to continue
	if not is_static_installed and not is_shared_installed:
		print_fail()
		print_exit("Static/Shared library '{0}' not installed. Install and try again.".format(lib_name))

	# Make them run updatedb if the library is not found by locate
	if is_static_installed:
		try:
			run_sync("locate /" + lib_name + ".a")
			print_ok()
			return
		except Exception as e:
			print_fail()
			print_exit("Static library '{0}' not found with 'locate'. Run 'sudo updatedb' and try again.".format(lib_name))

	# Make them run ldconfig if the library is not found by ld
	if is_shared_installed:
		f = tempfile.NamedTemporaryFile(delete=False)
		f.close()
		try:
			run_sync("ld -l " + lib_name.lstrip('lib') + ' -o ' + f.name)
			print_ok()
		except Exception as e:
			print_fail()
			print_exit("Shared library '{0}' not found with 'ld'. Run 'sudo ldconfig' and try again.".format(lib_name))
		finally:
			os.unlink(f.name)

def require_static_libraries(lib_names):
	for lib_name in lib_names:
		require_static_library(lib_name)

def require_shared_libraries(lib_names):
	for lib_name in lib_names:
		require_shared_library(lib_name)

def require_static_or_shared_libraries(lib_names):
	for lib_name in lib_names:
		require_static_or_shared_library(lib_name)

def require_raise_dependencies():
	# Get a list of all the programs raise uses
	prog_names = [
		'which', 'locate', 
		'gcc', 'ar', 'ld'
	]
	
	# Updatedb on BSD and OSX
	if os.path.exists('/usr/libexec/locate.updatedb'):
		prog_names.append('/usr/libexec/locate.updatedb')
	# Updatedb on Linux
	else:
		prog_names.append('updatedb')

	fails = []
	# See which programs are not installed
	for prog_name in prog_names:
		cb = lambda: run_sync('which {0}'.format(prog_name))
		try:
			cb()
		except Exception as e:
			fails.append(prog_name)

	# Print them in a list then exit
	if fails:
		print_info("Raise is checking for its dependencies")
		for f in fails:
			print_status("Checking for program '{0}'".format(f))
			print_fail()
		print_exit("Install the dependencies '{0}' and try again.".format(str.join("', '", fails)))

def require_programs(prog_names):
	for prog_name in prog_names:
		_do_on_fail_exit("Checking for program '{0}'".format(prog_name),
				"Install the program '{0}' and try again.".format(prog_name),
				lambda: run_sync('which {0}'.format(prog_name)))

def require_python_modules(mod_names):
	for mod_name in mod_names:
		_do_on_fail_exit("Checking for python module '{0}'".format(mod_name),
						"Install the python module '{0}' and try again.".format(mod_name),
					lambda: run_sync('{0} -c "import {1}"'.format(python, mod_name)))

def header_path(header_name):
	retval = None
	try:
		# Get any paths that contain the library name
		paths = run_sync('locate /' + header_name).split('\n')

		# First match paths that contain the architecture
		for path in paths:
			if 'lib' + bits in path or arch in path:
				retval = path

		# If none were matched specifically from the architecture
		# Use the first
		if retval == None:
			retval = paths[0]
	except Exception as e:
		pass

	if not retval or not os.path.exists(retval):
		raise Exception("Header file not found: '" + header_name + "'")

	i = retval.rfind('/') + 1
	return retval[:i]

def header_paths(header_names):
	paths = []
	for header_name in header_names:
		paths.append(header_path(header_name))

	return paths

def include_path(header_name):
	return '-I' + header_path(header_name)

def include_paths(header_names):
	paths = []
	for header_name in header_names:
		paths.append(include_path(header_name))
	return str.join(' ', paths)

def shared_library_path(lib_name):
	return _library_path(lib_name, '.so')

def static_library_path(lib_name):
	return _library_path(lib_name, '.a')

def static_or_shared_library_path(lib_name):
	try:
		return static_library_path(lib_name)
	except Exception as e:
		pass

	try:
		return shared_library_path(lib_name)
	except Exception as e:
		pass

	raise Exception("Static/Shared library not found: '" + lib_name + "'")

def link_shared_path(lib_name):
	return '-L' + shared_library_path(lib_name)

def link_static_path(lib_name):
	return '-L' + static_library_path(lib_name)

def link_static_or_shared_path(lib_name):
	return '-L' + static_or_shared_library_path(lib_name)

def link_shared_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_shared_path(lib_name))
	return str.join(' ', paths)

def link_static_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_static_path(lib_name))
	return str.join(' ', paths)

def link_static_or_shared_paths(lib_names):
	paths = []
	for lib_name in lib_names:
		paths.append(link_static_or_shared_path(lib_name))
	return str.join(' ', paths)

def c_build_object(o_file, c_files, i_files=[]):
	global g_events
	global is_parallel
	global parallel_message

	# Setup the messages for parallel and serial
	message = None
	if not is_parallel:
		message = "Building C object file '{0}'".format(o_file)
	else:
		parallel_message = "Building C object files in parallel ...\n"
		message = "    '{0}'".format(o_file)

	# Skip if the files have not changed since last build
	if not is_outdated(message, to_update = [o_file], triggers = c_files):
		return

	# Make sure the environmental variable is set
	if not 'CC' in os.environ:
		print_fail()
		print_exit("Set the env variable 'CC' to the C compiler, and try again.")

	# Create the event
	args = [o_file, c_files, i_files]
	func = _c_build_object
	event = Event(args, func, message)
	g_events.append(event)

	# If not parallel, run the event now
	if not is_parallel:
		parallel_end()

def _c_build_object(o_file, c_files, i_files=[]):
	return ProcessRunner("${CC} ${CFLAGS} -c -o " + o_file + ' ' + str.join(' ', c_files) + ' ' + str.join(' ', i_files))


def c_build_program(o_file, c_files, i_files=[]):
	global g_events
	global is_parallel
	global parallel_message

	# Setup the message
	message = "Building C program '{0}'".format(o_file)

	# Make sure the environmental variable is set
	if not 'CC' in os.environ:
		print_fail()
		print_exit("Set the env variable 'CC' to the C compiler, and try again.")

	# Create the event
	args = [o_file, c_files, i_files]
	func = _c_build_program
	event = Event(args, func, message)
	g_events.append(event)

	# Run the event now
	parallel_end()

def _c_build_program(o_file, c_files, i_files=[]):
	return ProcessRunner("${CC} ${CFLAGS} -o " + o_file + ' ' + str.join(' ', c_files) + ' ' + str.join(' ', i_files))


# FIXME: Rename to c_build_static_library
def ar_build_static_library(ar_file, o_files):
	message = "Building static library '{0}'".format(ar_file)
	if not is_outdated(message, to_update = [ar_file], triggers = o_files):
		return

	print_status(message)
	try:
		run_sync("ar rcs " + ar_file + " " + str.join(' ', o_files))
		print_ok()
	except Exception as e:
		print_fail()
		print(e)
		print_exit("Archive failed. Try again.")

def c_build_shared_library(so_file, o_files):
	message = "Building shared library '{0}'".format(so_file)
	if not is_outdated(message, to_update = [so_file], triggers = o_files):
		return

	print_status(message)
	try:
		command = "ld -G {0} -o {1}".format(str.join(' ', o_files), so_file)
		run_sync(command)
		print_ok()
	except Exception as e:
		print_fail()
		print(e)
		print_exit("Building shared library failed. Try again.")

def d_build_interface(d_file, i_files):
	message = "Building D interface file '{0}i'".format(d_file)
	if not is_outdated(message, to_update = [d_file+'i'], triggers = [d_file]):
		return

	print_status(message)
	f = tempfile.NamedTemporaryFile(delete=False)
	f.close()
	try:
		if not 'DC' in os.environ:
			print_fail()
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		command = "${DC} ${DFLAGS} -c " + d_file + " " + str.join(' ', i_files) + " -Hf" + d_file + "i -of" + f.name
		run_sync(command)
		print_ok()
	except Exception as e:
		print_fail()
		print(e)
		print_exit("Build failed. Try again.")
	finally:
		os.unlink(f.name)

def d_build_object(o_file, d_files, i_files, l_files=[], h_files=[]):
	message = "Building D object file '{0}'".format(o_file)
	if not is_outdated(message, to_update = [o_file], triggers = d_files):
		return

	print_status(message)
	try:
		if not 'DC' in os.environ:
			print_fail()
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		command = "${DC} ${DFLAGS} -c -of" + o_file + " " + str.join(' ', d_files) + " " + str.join(' ', i_files) + " " + str.join(' ', l_files)
		if h_files:
			command += " -H -Hdimport -Hf" + str.join(' ', h_files)
		run_sync(command)
		print_ok()
	except Exception as e:
		print_fail()
		print(e)
		print_exit("Build failed. Try again.")

def d_build_shared_library(o_file, d_files, i_files, l_files=[], generate_headers=False):
	message = "Building D shared library '{0}'".format(o_file)
	if not is_outdated(message, to_update = [o_file], triggers = d_files):
		return

	print_status(message)
	try:
		if not 'DC' in os.environ:
			print_fail()
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		command = "${DC} ${DFLAGS} -shared -of" + o_file + " " + str.join(' ', d_files) + " " + str.join(' ', i_files) + " " + str.join(' ', l_files)
		if generate_headers:
			command += "  -Hdimport -H"
		run_sync(command)
		print_ok()
	except Exception as e:
		print_fail()
		print(e)
		print_exit("Build failed. Try again.")

def d_build_static_library(o_file, d_files, i_files, l_files, generate_headers=False):
	print_status("Building D static library '{0}'".format(o_file))
	try:
		if not 'DC' in os.environ:
			print_fail()
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		command = "${DC} ${DFLAGS} -lib -of" + o_file + " " + str.join(' ', d_files) + " " + str.join(' ', i_files) + " " + str.join(' ', l_files)
		if generate_headers:
			command += "  -Hdimport -H"
		run_sync(command)
		print_ok()
	except Exception as e:
		print_fail()
		print(e)
		print_exit("Build failed. Try again.")

def d_build_program(out_file, inc_files, link_files=[]):
	print_status("Building D program '{0}'".format(out_file))
	try:
		if not 'DC' in os.environ:
			print_fail()
			print_exit("Set the env variable 'DC' to the D compiler, and try again.")

		command = "${DC} ${DFLAGS} -of" + out_file + ' ' + str.join(' ', inc_files) + " " + str.join(' ', link_files)
		run_sync(command)
		print_ok()
	except Exception as e:
		print_fail()
		print(e)
		print_exit("Build failed. Try again.")

def load_rscript(g=globals(), l=locals()):
	# Make sure there is an rscript file
	if not os.path.isfile('rscript'):
		return None

	# Get a list of all the functions
	before = []
	for key in globals().keys():
		before.append(key)

	# Load the rscript file into this namespace
	with open('rscript', 'rb') as f:
		code = None
		try:
			code = compile(f.read(), 'rscript', 'exec')
		except Exception as e:
			print_exit(e)

		exec(code, g, l)

	# Get just the target functions
	targets = {}
	for key in globals().keys():
		if not key in before:
			if not key.startswith('_') and hasattr(globals()[key], '__call__'):
				targets[key] = globals()[key]

	return targets

if __name__ == '__main__':
	# Have all KeyboardInterrupt exceptions quit with a clean message
	def signal_handler(signal, frame):
		print_exit('Exit called by the keyboard.')
		exit()
	signal.signal(signal.SIGINT, signal_handler)

	# Clear the terminal
	os.system(terminal_clear)
	
	# Load the rscript
	targets = load_rscript()

	# Get the target function name
	target_name = str(str.join(' ', sys.argv[1:]))

	# Get a friendly list of all the targets
	target_list = []
	if targets:
		keys = list(targets.keys())
		keys.sort()
		target_list = "'" + str.join("', '", keys) + "'"

	# Exit if there is no target
	if not target_name:
		print("Raise software build tool (Version 0.2 - August 29 2013) http://launchpad.net/raise")
		print("")
		print("COMMANDS:")
		print("\t./raise update - Downloads the newest version of Raise. It will be stored in a file named \".raise_actual\" or \"raise_actual\".")
		print("")

		# Print all the targets
		if targets:
			print("TARGETS:")
			for t in targets:
				no_doc = "No docstring is provided for this target."
				print("\t./raise " + t + " - " + (targets[t].__doc__ or no_doc))
				print("")
			print_exit("No target specified. Found targets are {0}.".format(target_list))
	
	if not targets:
		print_exit("No 'rscript' file found.")

	# Exit if there is no target with that name
	if not target_name in targets:
		print_exit("No target named '{0}'. Found targets are {1}.".format(target_name, target_list))

	# Make sure all the programs we need are installed
	# FIXME: Requiring gcc, ar, ld, and ldconfig makes raise
	# gcc specific. What other linkers and archivers are used
	# with other C compilers? Clang, MS cl, et cetera
	require_raise_dependencies()

	# Try running the target
	target = targets[target_name]
	print_info("Running target '{0}'".format(target_name))
	target()

